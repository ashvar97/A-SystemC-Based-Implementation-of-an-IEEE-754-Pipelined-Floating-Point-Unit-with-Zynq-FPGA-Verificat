
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2021 Cadence Design Systems, Inc. All rights reserved worldwide.
//
// The code contained herein is the proprietary and confidential information 
// of Cadence or its licensors, and is supplied subject to a previously 
// executed license and maintenance agreement between Cadence and customer. 
// Permission is only granted for use with Cadence high-level synthesis tools and
// may not be used with other high-level synthesis tools. Permission is only 
// granted to distribute the code as indicated. Cadence grants permission for 
// customer to distribute a copy of this code to any partner to aid in designing 
// or verifying the customer's intellectual property, as long as such 
// distribution includes a restriction of no additional distributions from the 
// partner, unless the partner receives permission directly from Cadence.
//
// ALL CODE FURNISHED BY CADENCE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, AND CADENCE SPECIFICALLY DISCLAIMS ANY WARRANTY OF NONINFRINGEMENT, 
// FITNESS FOR A PARTICULAR PURPOSE OR MERCHANTABILITY. CADENCE SHALL NOT BE 
// LIABLE FOR ANY COSTS OF PROCUREMENT OF SUBSTITUTES, LOSS OF PROFITS, 
// INTERRUPTION OF BUSINESS, OR FOR ANY OTHER SPECIAL, CONSEQUENTIAL OR 
// INCIDENTAL DAMAGES, HOWEVER CAUSED, WHETHER FOR BREACH OF WARRANTY, 
// CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR OTHERWISE.
//
////////////////////////////////////////////////////////////////////////////////


// Generated by bdw_memgen 22.01-s003
// Thu Mar 28 10:55:44 CET 2024



#ifndef hl5_block_1w1r_H
#define hl5_block_1w1r_H

#include "systemc.h"
#include "stratus_hls.h"


#if !defined(STRATUS_VLG)
#include "cynw_comm_util.h"
#include "cynw_fifo.h"
#endif
#include "cynw_memory.h"
#if defined STRATUS  &&  ! defined CYN_DONT_SUPPRESS_MSGS
#pragma cyn_suppress_msgs NOTE
#pragma hls_ip_def NOTE
#endif	// STRATUS  &&  CYN_DONT_SUPPRESS_MSGS
#if !defined(STRATUS_VLG)
#endif


#if defined(STRATUS_VLG) || defined(STRATUS_HLS)
SC_MODULE(hl5_block_1w1r)
#else
struct hl5_block_1w1r
  : public sc_module,
    public cynw_memory_if< sc_uint<10>, sc_uint<32> >
#endif
    {
	HLS_EXTERNAL_MODULE;

   sc_in< bool > CLK;
   sc_in< bool > WE0;
   sc_in< bool > CE0;
   sc_in< sc_uint<32> > D0;
   sc_in< sc_uint<10> > A0;
   sc_in< sc_uint<1> > WEM0;
   sc_in< bool > CE1;
   sc_out< sc_uint<32> > Q1;
   sc_in< sc_uint<10> > A1;
   sc_uint<32> mem[1024];
 
 

#if defined(__GNUC__) && defined(BDW_DEBUG_MEMS)
    double m_last_read_time;
    double m_last_write_time;
    uint64 m_last_read_addr;
    uint64 m_last_write_addr;
    int m_num_errors;
#endif

#if defined(__GNUC__) 
    cynw_memory_if< sc_uint<10>, sc_uint<32> >* m_iface;

    void set_iface( cynw_memory_if< sc_uint<10>, sc_uint<32> >* iface ) {
        m_iface = iface;
    }
    void sync_get( uint64 a ) {
       if ( m_iface ) {
           mem[ a ] = m_iface->get( a );
       }
    }
    void sync_put( uint64 a ) {
       if ( m_iface ) {
           m_iface->put( a, mem[ a ] );
       }
    }
#endif
#ifdef STRATUS_HLS
   sc_uint<32> write0(sc_uint<10> A0, sc_uint<32> D0, bool WE0=1, bool CE0=1, sc_uint<1> WEM0=~0);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   void nop0(bool WE0=0, bool CE0=0, sc_uint<1> WEM0=~0);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   sc_uint<32> read1(sc_uint<10> A1, bool CE1=1);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   void nop1(bool CE1=0);

#endif	// STRATUS_HLS
 
   void thread0();

   void thread1();

 
#if defined(STRATUS_VLG)
   SC_CTOR( hl5_block_1w1r );

#else
   SC_HAS_PROCESS( hl5_block_1w1r );

   hl5_block_1w1r( sc_module_name name = sc_module_name(sc_gen_unique_name("hl5_block_1w1r")));
#endif
   static const unsigned long implemented;
   static const unsigned long pipelined;
   static const float area;
   static const float delay;
   static const float setup_time;
   static const unsigned long latency_WE0;
   static const unsigned long latency_WEM0;
   static const unsigned long latency_CE0;
   static const unsigned long latency_D0;
   static const unsigned long latency_A0;
   static const unsigned long bits_per_maskbit_WEM0;
   static const unsigned long latency_CE1;
   static const unsigned long latency_A1;
   static const unsigned long bits_per_maskbit_WM1;
   static const unsigned long reg_mem_inputs;
   static const unsigned long reg_mem_outputs;
   static const unsigned long regs_at_mem_inputs;
   static const unsigned long regs_at_mem_outputs;
   static const unsigned long no_spec_reads;
   static const unsigned long is_mem;
   static const unsigned long clock_multiplier;
   static const bool has_extra_ports;
   static const bool is_prototype;
   static const char* naming_convention;


   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;
   
    enum {
        pipeline_depth = 1,
        mem_size = 1024,
        SIZE = 1024,
        address_width = 10,
        data_width = 32
    };


#if !defined(STRATUS_VLG) && !defined(STRATUS_HLS)
   // 
   // cynw_memory_if
   //
   data_type get( const address_type& address )
   {

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s: %s: read 0x%s from 0x%x\n", name(), sc_time_stamp().to_string().c_str(), mem[address.to_uint()].to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        return mem[address.to_uint()];
   }
   void put( const address_type& address, const data_type& data )
   {

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s%s: %s: write 0x%s to 0x%x\n", name(), "", sc_time_stamp().to_string().c_str(), data.to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        mem[address.to_uint()] = data;
#if defined(__GNUC__)
            sync_put(address.to_uint());
#endif

}

#endif

#if defined(__GNUC__) && BDW_USE_SCV
    cynw_scv_memory_tx_stream< sc_uint<10>, sc_uint<32> >* m_p1_tx_stream;
    cynw_scv_memory_tx< sc_uint<10>, sc_uint<32> > m_p1_tx_0;
    cynw_scv_memory_tx_stream< sc_uint<10>, sc_uint<32> >* m_p2_tx_stream;
    cynw_scv_memory_tx< sc_uint<10>, sc_uint<32> > m_p2_tx_0;
#endif


    //
    // External memory classes.
    //

    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class port;
    template <typename HLS_L=CYN::PIN> class ex_port;

    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class port_1;
    template <typename HLS_L=CYN::PIN> class ex_port_1;
    template <typename HLS_L=CYN::PIN> class reg_ex_port_1;
    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class stall_port_1;
    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class reg_port_1;

    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class port_2;
    template <typename HLS_L=CYN::PIN> class ex_port_2;
    template <typename HLS_L=CYN::PIN> class reg_ex_port_2;
    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class stall_port_2;
    template <typename HLS_L=CYN::PIN, typename HLS_ACCESS=sc_uint<32>, HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING = HLS::COMPACT > class reg_port_2;
    template <typename HLS_L=CYN::PIN> class wrapper;
    template <typename HLS_L=CYN::PIN> struct types;

};

// 
// struct containing signals to which a metaport for all interfaces can be bound.
// 
struct hl5_block_1w1r_ext_signals_0
{
    hl5_block_1w1r_ext_signals_0( const char* prefix=0 ) 
        :WE0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"WE0")))
        ,CE0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"CE0")))
        ,D0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"D0")))
        ,WEM0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"WEM0")))
        ,A0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"A0")))
        ,CE1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"CE1")))
        ,Q1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"Q1")))
        ,A1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"A1")))
    {}
   HLS_SC_SIGNAL_DECL( bool, true ) WE0;
   HLS_SC_SIGNAL_DECL( bool, true ) CE0;
   HLS_SC_SIGNAL_DECL( sc_uint<32>, true ) D0;
   HLS_SC_SIGNAL_DECL( sc_uint<1>, true ) WEM0;
   HLS_SC_SIGNAL_DECL( sc_uint<10>, true ) A0;

   HLS_SC_SIGNAL_DECL( bool, true ) CE1;
   HLS_SC_SIGNAL_DECL( sc_uint<32>, true ) Q1;
   HLS_SC_SIGNAL_DECL( sc_uint<10>, true ) A1;

};
// 
// struct containing signals to which a metaport can be bound
// for port #1
// 
struct hl5_block_1w1r_ext_signals_1
{
    hl5_block_1w1r_ext_signals_1( const char* prefix=0 ) 
        :WE0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"WE0")))
        ,CE0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"CE0")))
        ,D0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"D0")))
        ,WEM0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"WEM0")))
        ,A0(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"A0")))
    {}
   HLS_SC_SIGNAL_DECL( bool, true ) WE0;
   HLS_SC_SIGNAL_DECL( bool, true ) CE0;
   HLS_SC_SIGNAL_DECL( sc_uint<32>, true ) D0;
   HLS_SC_SIGNAL_DECL( sc_uint<1>, true ) WEM0;
   HLS_SC_SIGNAL_DECL( sc_uint<10>, true ) A0;

};
// 
// struct containing signals to which a metaport can be bound
// for port #2
// 
struct hl5_block_1w1r_ext_signals_2
{
    hl5_block_1w1r_ext_signals_2( const char* prefix=0 ) 
        :CE1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"CE1")))
        ,Q1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"Q1")))
        ,A1(sc_gen_unique_name(HLS_CAT_NAMES(prefix,"A1")))
    {}
   HLS_SC_SIGNAL_DECL( bool, true ) CE1;
   HLS_SC_SIGNAL_DECL( sc_uint<32>, true ) Q1;
   HLS_SC_SIGNAL_DECL( sc_uint<10>, true ) A1;

};

//
// Type declarations
//
// The members of this struct can be accessed directly to 
// identify a type related to this memory model.  This same
// struct is also a base class for most other types related
// to the memory, and so its members can be referenced as 
// members of those memory-related classes.
//
// The template parameter HLS_L can have the following values:
//
//	 PIN : Selects types for pin-level implementations.
//   TLM : Selects types for TLM implementations.
//   
// Note that since the memory model class itself if not 
// templated, only the PIN-level classes can be accessed via
// the main memory model class.
//
template <typename HLS_L>
struct hl5_block_1w1r::types
{  
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef sc_int<32>                       signed_type;
    typedef hl5_block_1w1r                             mem_type;
    typedef cynw_memory_if< address_type, data_type >    if_type;
    typedef hl5_block_1w1r::wrapper<HLS_L>                  wrapper;

    typedef hl5_block_1w1r::port<HLS_L,data_type>              port;
    typedef hl5_block_1w1r::ex_port<HLS_L>                     ex_port;

    typedef hl5_block_1w1r::port_1<HLS_L,data_type>           port_1;
    typedef hl5_block_1w1r::ex_port_1<HLS_L>                  ex_port_1;
    typedef hl5_block_1w1r::reg_ex_port_1<HLS_L>              reg_ex_port_1;
    typedef hl5_block_1w1r::reg_port_1<HLS_L,data_type>       reg_port_1;
    typedef hl5_block_1w1r::stall_port_1<HLS_L,data_type>     stall_port_1;

    typedef hl5_block_1w1r::port_2<HLS_L,data_type>           port_2;
    typedef hl5_block_1w1r::ex_port_2<HLS_L>                  ex_port_2;
    typedef hl5_block_1w1r::reg_ex_port_2<HLS_L>              reg_ex_port_2;
    typedef hl5_block_1w1r::reg_port_2<HLS_L,data_type>       reg_port_2;
    typedef hl5_block_1w1r::stall_port_2<HLS_L,data_type>     stall_port_2;
    typedef hl5_block_1w1r_ext_signals_0             ext_signals_0;
    typedef hl5_block_1w1r_ext_signals_1             ext_signals_1;
    typedef hl5_block_1w1r_ext_signals_2             ext_signals_2;

   
    enum {
        pipeline_depth = 1,
        mem_size = 1024,
        SIZE = 1024,
        address_width = 10,
        data_width = 32
    };

};


//
// Simple external memory wrapper.
//
// PIN-level version.
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
// 
//
template <typename HLS_L>
class hl5_block_1w1r::wrapper :
    public sc_module,
    public hl5_block_1w1r::types<HLS_L>
{
  public:
    typedef hl5_block_1w1r::wrapper<HLS_L>                 this_type;
  public:
    SC_HAS_PROCESS(wrapper);
    wrapper( sc_module_name in_name=sc_module_name( sc_gen_unique_name("hl5_block_1w1r")) )
      : sc_module(in_name)
      , model(basename())  
	  ,CLK("CLK")
      ,if1("if1"),if2("if2")
    {

        model.WE0(if1.WE0);
        model.CE0(if1.CE0);
        model.D0(if1.D0);
        model.A0(if1.A0);
        model.WEM0(if1.WEM0);
        model.CE1(if2.CE1);
        model.A1(if2.A1);
        model.Q1(if2.Q1);
        model.CLK(CLK);
    }
    template <class T0,class T1>
    void clk_rst( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_async( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_in<bool> & arst, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_signal<bool> & arst, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_in<bool> & arst, bool rah, bool arah )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_signal<bool> & arst, bool rah, bool arah )
    {
        CLK(CLK_in);
    }
    template <class T0>
    void clk_rst( T0 & CLK_in )
    {
        CLK(CLK_in);
    }

  public:
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    hl5_block_1w1r_ext_signals_1 if1;
    hl5_block_1w1r_ext_signals_2 if2;

    //
    // Ports.
    //
        sc_in_clk CLK;

    // 
    // The memory model.
    //
    hl5_block_1w1r            model;
};



#if !defined(STRATUS_VLG)
//
// PIN-level metaport for hierarchical binding to all memory ports.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port
  : public hl5_block_1w1r::types<HLS_L>
  , public cynw_clk_rst_facade
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::port<HLS_L,HLS_ACCESS,HLS_MAPPING>            this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;

    port( 
		const char* in_name=sc_gen_unique_name("port") )
    {
        p_name = new char[strlen(in_name)+1];
        strcpy(p_name,in_name);
	}

    ~port()
    {
        delete[] p_name;
    }

  public:
	char* p_name;

	const char* name() { return p_name; }


    void bind( this_type& p )
    {
        this->WE0(p.WE0);
        this->CE0(p.CE0);
        this->D0(p.D0);
        this->A0(p.A0);
        this->WEM0(p.WEM0);
        this->CE1(p.CE1);
        this->Q1(p.Q1);
        this->A1(p.A1);

    }

    void bind( hl5_block_1w1r_ext_signals_0& s )
    {
        this->WE0(s.WE0);
        this->CE0(s.CE0);
        this->D0(s.D0);
        this->A0(s.A0);
        this->WEM0(s.WEM0);
        this->CE1(s.CE1);
        this->Q1(s.Q1);
        this->A1(s.A1);

    }

    void bind( hl5_block_1w1r::wrapper<HLS_L>& w )
    {
        this->WE0(w.if1.WE0);
        this->CE0(w.if1.CE0);
        this->D0(w.if1.D0);
        this->A0(w.if1.A0);
        this->WEM0(w.if1.WEM0);
        this->CE1(w.if2.CE1);
        this->Q1(w.if2.Q1);
        this->A1(w.if2.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

	public:

   sc_out< bool > WE0;
   sc_out< bool > CE0;
   sc_out< sc_uint<32> > D0;
   sc_out< sc_uint<10> > A0;
   sc_out< sc_uint<1> > WEM0;
 
   sc_out< bool > CE1;
   sc_in< sc_uint<32> > Q1;
   sc_out< sc_uint<10> > A1;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level export metaport.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L>
class hl5_block_1w1r::ex_port
  : public hl5_block_1w1r::types<HLS_L>
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::ex_port<HLS_L>            this_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port( const char* in_name=sc_gen_unique_name("ex_port") )
    {}

  public:


    template <class W>
    void bind( W& iface )
    {
        WE0(iface.WE0);
        CE0(iface.CE0);
        D0(iface.D0);
        A0(iface.A0);
        WEM0(iface.WEM0);
        CE1(iface.CE1);
        Q1(iface.Q1);
        A1(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

  public:

   sc_export< sc_signal_out_if< bool > > WE0;
   sc_export< sc_signal_out_if< bool > > CE0;
   sc_export< sc_signal_out_if< sc_uint<32> > > D0;
   sc_export< sc_signal_out_if< sc_uint<10> > > A0;
   sc_export< sc_signal_out_if< sc_uint<1> > > WEM0;
 
   sc_export< sc_signal_out_if< bool > > CE1;
   sc_export< sc_signal_in_if< sc_uint<32> > > Q1;
   sc_export< sc_signal_out_if< sc_uint<10> > > A1;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port_1
  : public hl5_block_1w1r::types<HLS_L>
  , public cynw_clk_rst_facade
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>            this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef sc_uint<1>         mask_type;

    port_1( 
		const char* in_name=sc_gen_unique_name("port_1"),
		  unsigned options_in=0)
        : m_options(options_in|HLS_DEF_NO_CHAIN_MEM_IO | HLS_DEF_NO_SPEC_READS), 
          WE0( HLS_CAT_NAMES(in_name,"WE0") ),
        CE0( HLS_CAT_NAMES(in_name,"CE0") ),
        D0( HLS_CAT_NAMES(in_name,"D0") ),
        A0( HLS_CAT_NAMES(in_name,"A0") ),
        WEM0( HLS_CAT_NAMES(in_name,"WEM0") ),
          m_reset_done(false)
    {
        p_name = new char[strlen(in_name)+1];
        strcpy(p_name,in_name);
#if !STRATUS
        m_tx_stream = 0;
#endif
        m_stream_name = (std::string("sc_main.") + std::string(::sc_core::sc_get_curr_simcontext()->hierarchy_curr()->name()) + std::string(".") + std::string(in_name));
    }

    ~port_1()
    {
        delete[] p_name;
	}

    CYNW_MEM_SQUARE_BRACKETS( ref_type )
  public:
	char* p_name;
	bool m_reset_done;

	const char* name() { return p_name; }

    cynw_scv_memory_tx_stream< address_type, data_type >* tx_stream()
    {
#if !STRATUS
      if (m_tx_stream == 0) {
        esc_enable_scv_logging();
        m_tx_stream = new cynw_scv_memory_tx_stream< address_type, data_type >( m_stream_name.c_str(), esc_get_scv_tr_db() );
	  }
      return m_tx_stream;
#else
      return 0;
#endif
    }

    data_type get( const address_type& address )
    {
#if defined(STRATUS_HLS)
        HLS_MESSAGE(3571);
#elif !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        printf("WARNING: %s: Attempting to read from a write-only memory port\n", name());
#endif
        data_type rslt;
        return rslt;
    }
    void nb_put( const address_type& address, const data_type& data, const mask_type mask )
    {
        this->CE0 = 1;
        this->WE0 = 1;
        this->WEM0 = mask;
        this->A0 = address;
        this->D0 = data;
    }
    void put( const address_type& address, const data_type& data, mask_type mask )
    {
        HLS_DEFINE_FLOATING_PROTOCOL( 0, 0.0, 1, this, this->m_options|HLS::HLS_MEM_WRITE_FP|HLS::HLS_USING_REG_EX_PORT, address, "mem_write" );
        HLS_SET_OUTPUT_OPTIONS(this->D0,ASYNC_POWER_HOLD);
        HLS_SET_OUTPUT_OPTIONS(this->A0,ASYNC_POWER_HOLD);
        this->check_reset();
        cynw_scv_memory_tx< address_type, data_type > tx = this->tx_stream()->begin_write_tx( address, data );
        nb_put(address,data,mask);
        ::wait(1);
        nb_deassert();
        this->tx_stream()->end_write_tx( tx );
    }
    void nb_put( const address_type& address, const data_type& data )
    {
        nb_put(address, data, ~0);
    }
    void put( const address_type& address, const data_type& data )
    {
        put(address, data, ~0);
    }
    void reset( bool control_only=true )
    {
        HLS_DEFINE_PROTOCOL("reset");
        this->m_reset_done = true;
        this->WE0 = 0;
        if (!control_only) this->WEM0 = 0;
        this->CE0 = 0;
        if (!control_only) this->A0 = 0;
        if (!control_only) this->D0 = 0;
        HLS_SUPPRESS_MSG_SYM( 1435, this->A0 );
        HLS_SUPPRESS_MSG_SYM( 1435, this->D0 );
        HLS_SET_STALL_VALUE( this->CE0, 0);
    }

    void nb_deassert()
    {
        this->m_reset_done = true;
        this->WE0 = 0;
        this->WEM0 = 0;
        this->CE0 = 0;
    }

    void check_reset()
    {
#if !defined(STRATUS_HLS) && !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        if (!m_reset_done)
        {
            printf("WARNING: Access to external memory port '%s' before calling reset()\n", name());
            m_reset_done = true;
        }
#endif
    }

    template <class W>
    void bind( W& iface )
    {
        this->WE0(iface.WE0);
        this->CE0(iface.CE0);
        this->D0(iface.D0);
        this->A0(iface.A0);
        this->WEM0(iface.WEM0);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

  public:
	unsigned m_options;
#if !STRATUS
    cynw_scv_memory_tx_stream< address_type, data_type >* m_tx_stream;
#endif
	std::string m_stream_name;

   sc_out< bool > WE0;
   sc_out< bool > CE0;
   sc_out< sc_uint<32> > D0;
   sc_out< sc_uint<10> > A0;
   sc_out< sc_uint<1> > WEM0;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level export metaport.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L>
class hl5_block_1w1r::ex_port_1
  : public hl5_block_1w1r::types<HLS_L>
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::ex_port_1<HLS_L>            this_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port_1( const char* in_name=sc_gen_unique_name("ex_port_1") )
        : WE0( HLS_CAT_NAMES(in_name,"WE0") ),
        CE0( HLS_CAT_NAMES(in_name,"CE0") ),
        D0( HLS_CAT_NAMES(in_name,"D0") ),
        A0( HLS_CAT_NAMES(in_name,"A0") ),
        WEM0( HLS_CAT_NAMES(in_name,"WEM0") )
    {}

  public:


    template <class W>
    void bind( W& iface )
    {
        WE0(iface.WE0);
        CE0(iface.CE0);
        D0(iface.D0);
        A0(iface.A0);
        WEM0(iface.WEM0);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

  public:

   sc_export< sc_signal_out_if< bool > > WE0;
   sc_export< sc_signal_out_if< bool > > CE0;
   sc_export< sc_signal_out_if< sc_uint<32> > > D0;
   sc_export< sc_signal_out_if< sc_uint<10> > > A0;
   sc_export< sc_signal_out_if< sc_uint<1> > > WEM0;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level export metaport with a register included.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L>
class hl5_block_1w1r::reg_ex_port_1
  : public hl5_block_1w1r::ex_port_1<HLS_L>,
	public sc_module,
	public cynw_clk_rst

{
  public:
    typedef hl5_block_1w1r::reg_ex_port_1<HLS_L>            this_type;
    typedef hl5_block_1w1r::ex_port_1<HLS_L>            base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    SC_HAS_PROCESS(this_type);

    reg_ex_port_1( sc_module_name in_name=sc_module_name( sc_gen_unique_name("reg_ex_port_1") ) )
        : base_type(in_name)
		, sc_module(in_name)
		, WE0_reg( HLS_CAT_NAMES(in_name,"WE0_reg") ),
        CE0_reg( HLS_CAT_NAMES(in_name,"CE0_reg") ),
        D0_reg( HLS_CAT_NAMES(in_name,"D0_reg") ),
        A0_reg( HLS_CAT_NAMES(in_name,"A0_reg") ),
        WEM0_reg( HLS_CAT_NAMES(in_name,"WEM0_reg") )
		, WE0_p( HLS_CAT_NAMES(in_name,"WE0_p") ),
        CE0_p( HLS_CAT_NAMES(in_name,"CE0_p") ),
        D0_p( HLS_CAT_NAMES(in_name,"D0_p") ),
        A0_p( HLS_CAT_NAMES(in_name,"A0_p") ),
        WEM0_p( HLS_CAT_NAMES(in_name,"WEM0_p") )
    {
        this->WE0(WE0_reg);
        this->CE0(CE0_reg);
        this->D0(D0_reg);
        this->A0(A0_reg);
        this->WEM0(WEM0_reg);


        SC_METHOD(do_reg);
        sensitive << clk.pos();
        dont_initialize();

	}

  public:


    template <class W>
    void bind( W& iface )
    {
        WE0_p(iface.WE0);
        CE0_p(iface.CE0);
        D0_p(iface.D0);
        A0_p(iface.A0);
        WEM0_p(iface.WEM0);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

    void do_reg()
    {
        if ( rst_active() ) 
        {
	         HLS_SET_IS_RESET_BLOCK("do_reg");
            WE0_p = 0;
            WEM0_p = 0;
            CE0_p = 0;
        } else {
            WE0_p.write( WE0_reg.read() );
            CE0_p.write( CE0_reg.read() );
            WEM0_p.write( WEM0_reg.read() );
            D0_p.write( D0_reg.read() );
            A0_p.write( A0_reg.read() );

        }
    }
  public:

        sc_signal< bool > WE0_reg;
        sc_signal< bool > CE0_reg;
        sc_signal< sc_uint<32> > D0_reg;
        sc_signal< sc_uint<10> > A0_reg;
        sc_signal< sc_uint<1> > WEM0_reg;
        sc_out< bool > WE0_p;
        sc_out< bool > CE0_p;
        sc_out< sc_uint<32> > D0_p;
        sc_out< sc_uint<10> > A0_p;
        sc_out< sc_uint<1> > WEM0_p;
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport with stalling support.
// Since this is a write-only port, no stalling support is required.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::stall_port_1
  : public hl5_block_1w1r::port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>
{
  public:
    typedef hl5_block_1w1r::port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>       base_type;

    stall_port_1( const char* in_name=sc_gen_unique_name("port_1"), unsigned options_in=0 )
      : base_type(in_name,options_in)
    {}
};
#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport with an explicit register on DOUT support.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::reg_port_1
  : public hl5_block_1w1r::port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>,
    public sc_module,
    public cynw_clk_rst
{
  public:
    typedef hl5_block_1w1r::reg_port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>       this_type;
    typedef hl5_block_1w1r::port_1<HLS_L,HLS_ACCESS,HLS_MAPPING>       base_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef sc_uint<1>           mask_type;

    SC_HAS_PROCESS(this_type);

    HLS_EXPOSE_PORT( OFF, clk );
    HLS_EXPOSE_PORT( OFF, rst );

    reg_port_1( 
	  sc_module_name in_name=sc_module_name( sc_gen_unique_name("port_1") ), 
	  unsigned options_in=0 )
      : sc_module(in_name)
	  ,	cynw_clk_rst(in_name)
	  ,	base_type(in_name,options_in|HLS_DEF_NO_CHAIN_MEM_IO | HLS_DEF_NO_SPEC_READS)
    {

	  SC_METHOD(do_reg_c);
      sensitive << clk.pos();
      dont_initialize();

	  SC_METHOD(do_reg_din);
      sensitive << clk.pos();
      dont_initialize();

    }

    CYNW_MEM_SQUARE_BRACKETS( ref_type )

	CYNW_CLK_RST_FUNCS

  public:
    data_type get( const address_type& address )
    {
#if defined(STRATUS_HLS)
        HLS_MESSAGE(3571);
#elif !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        printf("WARNING: %s: Attempting to read from a write-only memory port\n", name());
#endif
        data_type rslt;
        return rslt;
    }
    void nb_put( const address_type& address, const data_type& data, const mask_type mask )
    {
        this->if_inner.CE0 = 1;
        this->if_inner.WE0 = 1;
        this->if_inner.WEM0 = mask;
        this->if_inner.A0 = address;
        this->if_inner.D0 = data;
    }
    void put( const address_type& address, const data_type& data, mask_type mask )
    {
        HLS_DEFINE_FLOATING_PROTOCOL( HLS_REG_SETUP_TIME, 0.0, 1, this, this->m_options|HLS::HLS_MEM_WRITE_FP|HLS::HLS_USING_REG_EX_PORT, address, "mem_write" );
        HLS_SET_OUTPUT_OPTIONS(this->if_inner.D0,ASYNC_POWER_HOLD);
        HLS_SET_OUTPUT_OPTIONS(this->if_inner.A0,ASYNC_POWER_HOLD);
        this->check_reset();
        cynw_scv_memory_tx< address_type, data_type > tx = this->tx_stream()->begin_write_tx( address, data );
        nb_put(address,data,mask);
        ::wait(1);
        nb_deassert();
        this->tx_stream()->end_write_tx( tx );
    }
    void nb_put( const address_type& address, const data_type& data )
    {
        nb_put(address, data, ~0);
    }
    void put( const address_type& address, const data_type& data )
    {
        put(address, data, ~0);
    }
    void reset( bool control_only=true )
    {
        HLS_DEFINE_PROTOCOL("reset");
        this->m_reset_done = true;
        this->if_inner.WE0 = 0;
        if (!control_only) this->if_inner.WEM0 = 0;
        this->if_inner.CE0 = 0;
        if (!control_only) this->if_inner.A0 = 0;
        if (!control_only) this->if_inner.D0 = 0;
        HLS_SUPPRESS_MSG_SYM( 1435, this->if_inner.A0 );
        HLS_SUPPRESS_MSG_SYM( 1435, this->if_inner.D0 );
        HLS_SET_STALL_VALUE( this->if_inner.CE0, 0);
    }

    void nb_deassert()
    {
        this->m_reset_done = true;
        this->if_inner.WE0 = 0;
        this->if_inner.WEM0 = 0;
        this->if_inner.CE0 = 0;
    }

    template <class W>
    void bind( W& iface )
    {
        this->WE0(iface.WE0);
        this->CE0(iface.CE0);
        this->D0(iface.D0);
        this->A0(iface.A0);
        this->WEM0(iface.WEM0);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }
    hl5_block_1w1r_ext_signals_1    if_inner;

    void do_reg_c()
    {
        if ( rst_active() ) 
        {
            HLS_SET_IS_RESET_BLOCK("do_reg_c");
            this->WE0 = 0;
            this->WEM0 = 0;
            this->CE0 = 0;
        } else {
            this->WE0.write( if_inner.WE0.read() );
            this->CE0.write( if_inner.CE0.read() );
            this->WEM0.write( if_inner.WEM0.read() );

        }
    }

    void do_reg_din()
    {
	bool rst = rst_active(); 
         if ( if_inner.CE0.read() == 1 ) {
             HLS_REMOVE_CONTROL(OFF,"");
            this->D0.write( if_inner.D0.read() );
            this->A0.write( if_inner.A0.read() );
         }

    }

};
#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port_2
  : public hl5_block_1w1r::types<HLS_L>
  , public cynw_clk_rst_facade
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>            this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef unsigned int                          mask_type;

    port_2( 
		const char* in_name=sc_gen_unique_name("port_2"),
		  unsigned options_in=0)
        : m_options(options_in|HLS_DEF_NO_CHAIN_MEM_IO | HLS_DEF_NO_SPEC_READS), 
          CE1( HLS_CAT_NAMES(in_name,"CE1") ),
        Q1( HLS_CAT_NAMES(in_name,"Q1") ),
        A1( HLS_CAT_NAMES(in_name,"A1") ),
          m_reset_done(false)
    {
        p_name = new char[strlen(in_name)+1];
        strcpy(p_name,in_name);
#if !STRATUS
        m_tx_stream = 0;
#endif
        m_stream_name = (std::string("sc_main.") + std::string(::sc_core::sc_get_curr_simcontext()->hierarchy_curr()->name()) + std::string(".") + std::string(in_name));
    }

    ~port_2()
    {
        delete[] p_name;
	}

    CYNW_MEM_SQUARE_BRACKETS( ref_type )
  public:
	char* p_name;
	bool m_reset_done;

	const char* name() { return p_name; }

    cynw_scv_memory_tx_stream< address_type, data_type >* tx_stream()
    {
#if !STRATUS
      if (m_tx_stream == 0) {
        esc_enable_scv_logging();
        m_tx_stream = new cynw_scv_memory_tx_stream< address_type, data_type >( m_stream_name.c_str(), esc_get_scv_tr_db() );
	  }
      return m_tx_stream;
#else
      return 0;
#endif
    }

    void nb_get_start( const address_type& address )
    {
        this->CE1 = 1;
        this->A1 = address;
    }
    bool nb_get( data_type& val )
    {
        val = this->Q1.read();
        return true;
    }
    sc_event_finder& value_changed()
    {
        return this->Q1.value_changed();
    }
    data_type get( const address_type& address )
    {
        HLS_DEFINE_FLOATING_PROTOCOL( 0, 0, 1, this, this->m_options|HLS::HLS_MEM_READ_FP|HLS::HLS_UNSTALLABLE_FP, address, "mem_read" );
        HLS_SET_OUTPUT_OPTIONS(this->A1,ASYNC_POWER_HOLD);
        this->check_reset();
        cynw_scv_memory_tx< address_type, data_type > tx = this->tx_stream()->begin_read_tx( address );
        nb_get_start(address);
        ::wait(1);
        nb_deassert();
        ::wait( 1 );
        if (this->m_options & HLS::HLS_USING_REG_PORT) {
            ::wait(1);
            ::wait(1);
        }
        if (this->m_options & HLS::HLS_USING_REG_EX_PORT) {
            ::wait(1);
            ::wait(1);
        }

        data_type val;
        nb_get(val);
        this->tx_stream()->end_read_tx( tx, val );
        return val;
    }
    void put( const address_type& address, const data_type& data )
    {
#if defined(STRATUS_HLS)
        HLS_MESSAGE(3570);
#elif !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        printf("WARNING: %s: Attempting to write to a read-only memory port\n", name());
#endif
    }
    void reset( bool control_only=true )
    {
        HLS_DEFINE_PROTOCOL("reset");
        this->m_reset_done = true;
        this->CE1 = 0;
        if (!control_only) this->A1 = 0;
        HLS_SUPPRESS_MSG_SYM( 1435, this->A1 );
        HLS_SET_STALL_VALUE( this->CE1, 0);
    }

    void nb_deassert()
    {
        this->m_reset_done = true;
        this->CE1 = 0;
    }

    void check_reset()
    {
#if !defined(STRATUS_HLS) && !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        if (!m_reset_done)
        {
            printf("WARNING: Access to external memory port '%s' before calling reset()\n", name());
            m_reset_done = true;
        }
#endif
    }

    template <class W>
    void bind( W& iface )
    {
        this->CE1(iface.CE1);
        this->Q1(iface.Q1);
        this->A1(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

  public:
	unsigned m_options;
#if !STRATUS
    cynw_scv_memory_tx_stream< address_type, data_type >* m_tx_stream;
#endif
	std::string m_stream_name;

   sc_out< bool > CE1;
   sc_in< sc_uint<32> > Q1;
   sc_out< sc_uint<10> > A1;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level export metaport.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L>
class hl5_block_1w1r::ex_port_2
  : public hl5_block_1w1r::types<HLS_L>
{
  public:
    HLS_METAPORT;
    typedef hl5_block_1w1r::ex_port_2<HLS_L>            this_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port_2( const char* in_name=sc_gen_unique_name("ex_port_2") )
        : CE1( HLS_CAT_NAMES(in_name,"CE1") ),
        Q1( HLS_CAT_NAMES(in_name,"Q1") ),
        A1( HLS_CAT_NAMES(in_name,"A1") )
    {}

  public:


    template <class W>
    void bind( W& iface )
    {
        CE1(iface.CE1);
        Q1(iface.Q1);
        A1(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

  public:

   sc_export< sc_signal_out_if< bool > > CE1;
   sc_export< sc_signal_in_if< sc_uint<32> > > Q1;
   sc_export< sc_signal_out_if< sc_uint<10> > > A1;
 
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level export metaport with a register included.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L>
class hl5_block_1w1r::reg_ex_port_2
  : public hl5_block_1w1r::ex_port_2<HLS_L>,
	public sc_module,
	public cynw_clk_rst

{
  public:
    typedef hl5_block_1w1r::reg_ex_port_2<HLS_L>            this_type;
    typedef hl5_block_1w1r::ex_port_2<HLS_L>            base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    SC_HAS_PROCESS(this_type);

    reg_ex_port_2( sc_module_name in_name=sc_module_name( sc_gen_unique_name("reg_ex_port_2") ) )
        : base_type(in_name)
		, sc_module(in_name)
		, CE1_reg( HLS_CAT_NAMES(in_name,"CE1_reg") ),
        Q1_reg( HLS_CAT_NAMES(in_name,"Q1_reg") ),
        A1_reg( HLS_CAT_NAMES(in_name,"A1_reg") )
		, CE1_p( HLS_CAT_NAMES(in_name,"CE1_p") ),
        Q1_p( HLS_CAT_NAMES(in_name,"Q1_p") ),
        A1_p( HLS_CAT_NAMES(in_name,"A1_p") )
    {
        this->CE1(CE1_reg);
        this->Q1(Q1_reg);
        this->A1(A1_reg);


        SC_METHOD(do_reg);
        sensitive << clk.pos();
        dont_initialize();

	}

  public:


    template <class W>
    void bind( W& iface )
    {
        CE1_p(iface.CE1);
        Q1_p(iface.Q1);
        A1_p(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

    void do_reg()
    {
        if ( rst_active() ) 
        {
	         HLS_SET_IS_RESET_BLOCK("do_reg");
            CE1_p = 0;
        } else {
            CE1_p.write( CE1_reg.read() );
            Q1_reg.write( Q1_p.read() );
            A1_p.write( A1_reg.read() );

        }
    }
  public:

        sc_signal< bool > CE1_reg;
        sc_signal< sc_uint<32> > Q1_reg;
        sc_signal< sc_uint<10> > A1_reg;
        sc_out< bool > CE1_p;
        sc_out< sc_uint<10> > A1_p;
        sc_in< sc_uint<32> > Q1_p;
};

#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport with stalling support.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::stall_port_2
  : public hl5_block_1w1r::port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>,
    public sc_module,
    public cynw_clk_rst
{
  public:
    typedef hl5_block_1w1r::stall_port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>       this_type;
    typedef hl5_block_1w1r::port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>       base_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef unsigned int                          mask_type;

    SC_HAS_PROCESS(this_type);

    HLS_EXPOSE_PORT( OFF, clk );
    HLS_EXPOSE_PORT( OFF, rst );

    sc_signal<data_type> fifo_dout;
    sc_signal<bool> tx_start;
    sc_signal<bool> tx_end;
    sc_signal<bool> tx_running;
    sc_signal<bool> m_stalling;
    sc_signal<bool> CE1_req;

    stall_port_2( 
	  sc_module_name in_name=sc_module_name( sc_gen_unique_name("port_2") ), unsigned options_in=0)
      : sc_module(in_name),
		cynw_clk_rst(in_name),
		base_type(in_name,options_in|HLS_DEF_NO_CHAIN_MEM_IO | HLS_DEF_NO_SPEC_READS),
		fifo(in_name),
        tx_start("tx_start"),
        tx_end("tx_end"),
        m_stalling("m_stalling")
    {

      fifo.stalling(m_stalling);
      fifo.start(tx_start);
      fifo.end(tx_end);
      fifo.running(tx_running);
      fifo.din(this->Q1);
      fifo.dout(fifo_dout);
      fifo.clk_rst(*this);
      HLS_SET_OUTPUT_OPTIONS( this->CE1, ASYNC_HOLD_WEAK_TIMING );

      SC_METHOD(gen_CE1);
	  sensitive << CE1_req;
	  sensitive << m_stalling;

    }

    CYNW_MEM_SQUARE_BRACKETS( ref_type )

	CYNW_CLK_RST_FUNCS

  public:

    // 
    // Fifo for storing memory outputs during a stall.
    // Depth matches the latency of the memory.
    //
    cynw_stall_fifo< data_type, 1, HLS_L > fifo;


    void nb_get_start( const address_type& address )
    {
        this->CE1_req = 1;
        this->A1 = address;
        tx_start = 1;
    }
    bool nb_get( data_type& val )
    {
        val = this->fifo_dout.read();
        return true;
    }
    data_type get( const address_type& address )
    {
        HLS_DEFINE_FLOATING_PROTOCOL( 0, -1, 1, this, this->m_options|HLS::HLS_MEM_READ_FP, address, "mem_read" );
        HLS_SET_OUTPUT_OPTIONS(this->A1,ASYNC_POWER_HOLD);
        this->check_reset();
        cynw_scv_memory_tx< address_type, data_type > tx = this->tx_stream()->begin_read_tx( address );
        nb_get_start(address);
        ::wait(1);
        nb_deassert();
        ::wait( 1 );
        if (this->m_options & HLS::HLS_USING_REG_PORT) {
            ::wait(1);
            ::wait(1);
        }
        if (this->m_options & HLS::HLS_USING_REG_EX_PORT) {
            ::wait(1);
            ::wait(1);
        }

        data_type val;
        nb_get(val);
        this->tx_stream()->end_read_tx( tx, val );
        return val;
    }
    void put( const address_type& address, const data_type& data )
    {
#if defined(STRATUS_HLS)
        HLS_MESSAGE(3570);
#elif !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        printf("WARNING: %s: Attempting to write to a read-only memory port\n", name());
#endif
    }
    void reset( bool control_only=true )
    {
        HLS_DEFINE_PROTOCOL("reset");
        this->m_reset_done = true;
        this->CE1_req = 0;
        if (!control_only) this->A1 = 0;
        HLS_SUPPRESS_MSG_SYM( 1435, this->A1 );
        tx_start = 0;
        cynw_assert_during_stall( m_stalling, 1 );
        HLS_SET_STALL_VALUE( this->CE1, 0);
    }

    void nb_deassert()
    {
        this->m_reset_done = true;
        this->CE1_req = 0;
        tx_start = 0;
    }

    template <class W>
    void bind( W& iface )
    {
        this->CE1(iface.CE1);
        this->Q1(iface.Q1);
        this->A1(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }

	void gen_CE1()
	{
	    this->CE1.write( CE1_req.read() & !m_stalling.read() );
	}
};
#endif

#if !defined(STRATUS_VLG)
//
// PIN-level metaport with an explicit register on DOUT support.
//
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_L,typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::reg_port_2
  : public hl5_block_1w1r::port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>,
    public sc_module,
    public cynw_clk_rst
{
  public:
    typedef hl5_block_1w1r::reg_port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>       this_type;
    typedef hl5_block_1w1r::port_2<HLS_L,HLS_ACCESS,HLS_MAPPING>       base_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS, HLS_MAPPING > ref_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef unsigned int                          mask_type;

    SC_HAS_PROCESS(this_type);

    HLS_EXPOSE_PORT( OFF, clk );
    HLS_EXPOSE_PORT( OFF, rst );

    reg_port_2( 
	  sc_module_name in_name=sc_module_name( sc_gen_unique_name("port_2") ), 
	  unsigned options_in=0 )
      : sc_module(in_name)
	  ,	cynw_clk_rst(in_name)
	  ,	base_type(in_name,options_in|HLS_DEF_NO_CHAIN_MEM_IO | HLS_DEF_NO_SPEC_READS)
    {

	  SC_METHOD(do_reg_c);
      sensitive << clk.pos();
      dont_initialize();

	  SC_METHOD(do_reg_din);
      sensitive << clk.pos();
      dont_initialize();

	  SC_METHOD(do_reg_dout);
      sensitive << clk.pos();
      dont_initialize();

    }

    CYNW_MEM_SQUARE_BRACKETS( ref_type )

	CYNW_CLK_RST_FUNCS

  public:
    void nb_get_start( const address_type& address )
    {
        this->if_inner.CE1 = 1;
        this->if_inner.A1 = address;
    }
    bool nb_get( data_type& val )
    {
        val = this->if_inner.Q1.read();
        return true;
    }
    data_type get( const address_type& address )
    {
        HLS_DEFINE_FLOATING_PROTOCOL( HLS_REG_SETUP_TIME, HLS_REG_DELAY, 1, this, this->m_options|HLS::HLS_MEM_READ_FP|HLS::HLS_UNSTALLABLE_FP, address, "mem_read" );
        HLS_SET_OUTPUT_OPTIONS(this->if_inner.A1,ASYNC_POWER_HOLD);
        this->check_reset();
        cynw_scv_memory_tx< address_type, data_type > tx = this->tx_stream()->begin_read_tx( address );
        nb_get_start(address);
        ::wait(1);
        nb_deassert();
        ::wait( 3 );
        if (this->m_options & HLS::HLS_USING_REG_EX_PORT) {
            ::wait(1);
            ::wait(1);
        }

        data_type val;
        nb_get(val);
        this->tx_stream()->end_read_tx( tx, val );
        return val;
    }
    void put( const address_type& address, const data_type& data )
    {
#if defined(STRATUS_HLS)
        HLS_MESSAGE(3570);
#elif !defined(STRATUS_VLG) && !defined(BDW_EXTRACT)
        printf("WARNING: %s: Attempting to write to a read-only memory port\n", name());
#endif
    }
    void reset( bool control_only=true )
    {
        HLS_DEFINE_PROTOCOL("reset");
        this->m_reset_done = true;
        this->if_inner.CE1 = 0;
        if (!control_only) this->if_inner.A1 = 0;
        HLS_SUPPRESS_MSG_SYM( 1435, this->if_inner.A1 );
        HLS_SET_STALL_VALUE( this->if_inner.CE1, 0);
    }

    void nb_deassert()
    {
        this->m_reset_done = true;
        this->if_inner.CE1 = 0;
    }

    template <class W>
    void bind( W& iface )
    {
        this->CE1(iface.CE1);
        this->Q1(iface.Q1);
        this->A1(iface.A1);

    }

    template <class W>
    void operator()( W& iface )
    {
      bind(iface);
    }
    hl5_block_1w1r_ext_signals_2    if_inner;

    void do_reg_c()
    {
        if ( rst_active() ) 
        {
            HLS_SET_IS_RESET_BLOCK("do_reg_c");
            this->CE1 = 0;
        } else {
            this->CE1.write( if_inner.CE1.read() );

        }
    }

    void do_reg_din()
    {
	bool rst = rst_active(); 
         if ( if_inner.CE1.read() == 1 ) {
             HLS_REMOVE_CONTROL(OFF,"");
            this->A1.write( if_inner.A1.read() );
         }

    }

    void do_reg_dout()
    {
	bool rst = rst_active(); 
            if_inner.Q1.write( this->Q1.read() );

    }

};
#endif

#if !defined(STRATUS_VLG)
//
// Simple memory model containing a SystemC array 
// to represent the memory.
//
class hl5_block_1w1r_untimed_model
  : public sc_module,
    public cynw_memory_if< sc_uint<10>, sc_uint<32> >
{
  public:
    typedef hl5_block_1w1r_untimed_model            this_type;
    typedef sc_uint<10>              address_type;
    typedef sc_uint<32>               data_type;
  public:
    SC_CTOR(hl5_block_1w1r_untimed_model)
    {

        esc_enable_scv_logging();
        m_tx_stream = new cynw_scv_memory_tx_stream< sc_uint<10>, sc_uint<32> >( (std::string("sc_main.") + std::string(this->name())).c_str(), esc_get_scv_tr_db() );
    }

    data_type get( const address_type& address )
    {
#if defined(__GNUC__)
      if((int)(address) >=  1024) return 0;
#endif
        m_tx_stream->gen_read_tx( address.to_uint(), mem[address.to_uint()] );

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s: %s: read 0x%s from 0x%x\n", name(), sc_time_stamp().to_string().c_str(), mem[address.to_uint()].to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        return mem[address.to_uint()];
}


    void put( const address_type& address, const data_type& data )
    {
#if defined(__GNUC__)
      if((int)(address) >=  1024) return;
#endif
        m_tx_stream->gen_write_tx( address.to_uint(), data );

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s%s: %s: write 0x%s to 0x%x\n", name(), "", sc_time_stamp().to_string().c_str(), data.to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        mem[address.to_uint()] = data;
    }


    cynw_scv_memory_tx_stream< sc_uint<10>, sc_uint<32> >* m_tx_stream;

    // 
    // Array containing memory contents
    //
    sc_uint<32> mem[1024];
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public cynw_clk_rst_facade,
    public sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    HLS_METAPORT;

    typedef hl5_block_1w1r::port< CYN::TLM, HLS_ACCESS,HLS_MAPPING>   this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS,HLS_MAPPING > ref_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;

    port( const char* in_name=sc_gen_unique_name("port") )
      : base_type(in_name)
    {
	}

  public:
};
#endif



#if !defined(STRATUS_VLG)
//
// TLM export metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <>
class hl5_block_1w1r::ex_port<CYN::TLM>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    typedef hl5_block_1w1r::ex_port< CYN::TLM>   this_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port( const char* name=0 )
      : base_type(name)
    {}

  public:

};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public cynw_clk_rst_facade,
    public sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    HLS_METAPORT;

    typedef hl5_block_1w1r::port_1< CYN::TLM, HLS_ACCESS,HLS_MAPPING>   this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS,HLS_MAPPING > ref_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef sc_uint<1>                          mask_type;

    port_1( const char* in_name=sc_gen_unique_name("port_1"), unsigned options_in=0 )
      : base_type(in_name), m_options(options_in)
    {
       m_tx_stream = 0;
       m_stream_name = (std::string("sc_main.") + std::string(this->name()));

	}

    CYNW_MEM_SQUARE_BRACKETS( ref_type )

    cynw_scv_memory_tx_stream< address_type, data_type >* tx_stream()
    {
#if !STRATUS
      if (m_tx_stream == 0) {
        esc_enable_scv_logging();
        m_tx_stream = new cynw_scv_memory_tx_stream< address_type, data_type >( m_stream_name.c_str(), esc_get_scv_tr_db() );
	  }
      return m_tx_stream;
#else
      return 0;
#endif
    }

  public:

    void nb_get_start( const address_type& address )
	{
		m_val = get(address);
	}

    bool nb_get( data_type& val )
    {

        val = m_val;
		return true;
    }

	sc_event_finder& value_changed()
	{
        return *(new sc_event_finder_t<cynw_memory_if< sc_uint<10>, sc_uint<32> > >(*this));
	}
    data_type get( const address_type& address )
    {

        data_type rslt;
        if ( (m_options & HLS::HLS_INTERNAL_ONLY) == 0) {
            printf("WARNING: %s: Attempting to read from a write-only memory port\n", name());
        } else {
		    rslt = (*this)->get(address);
        }
        return rslt;
    }

    void put( const address_type& address, const data_type& data )
    {
        this->tx_stream()->gen_write_tx( address, data );
        (*this)->put(address,data);
    }

    void nb_put( const address_type& address, const data_type& data )
    {
        (*this)->put(address,data);
    }
    
    void put( const address_type& address, const data_type& data, mask_type mask )
    {
        data_type tmp = (*this)->get(address);
        if( mask[0] == 1 )
        {
            tmp.range(31,0) = data.range(31,0);
        }
        (*this)->put(address,tmp);
    }

	void nb_deassert()
    {
    }

    void reset(  bool control_only=true )
    {
    }

  public:
    unsigned m_options;
    data_type m_val;
    cynw_scv_memory_tx_stream< address_type, data_type >* m_tx_stream;
    std::string m_stream_name;
};
#endif



#if !defined(STRATUS_VLG)
//
// TLM export metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <>
class hl5_block_1w1r::ex_port_1<CYN::TLM>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    typedef hl5_block_1w1r::ex_port_1< CYN::TLM>   this_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port_1( const char* name=0, unsigned options_in=0 )
      : base_type(name)
    {}

  public:

};
#endif


#if !defined(STRATUS_VLG)
//
// TLM registered export metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <>
class hl5_block_1w1r::reg_ex_port_1<CYN::TLM>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > >,
	public cynw_clk_rst_facade
{
  public:
    typedef hl5_block_1w1r::reg_ex_port_1< CYN::TLM>   this_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    reg_ex_port_1( const char* name=0, unsigned options_in=0 )
      : base_type(name)
    {}

  public:
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport with stalling support.
//  
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::stall_port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
{   
  public:
    typedef hl5_block_1w1r::port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  base_type;
        
    stall_port_1( const char* name=0, unsigned options_in=0 )
      : base_type(name,options_in)
    {   
    }
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport with stalling support.
//  
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::reg_port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
{   
  public:
    typedef hl5_block_1w1r::port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  base_type;
    typedef hl5_block_1w1r::reg_port_1<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  this_type;
        
    reg_port_1( const char* name=0, unsigned options_in=0 )
      : base_type(name,options_in), if_inner(*this)
    {   
    }

	this_type& if_inner;
	
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public cynw_clk_rst_facade,
    public sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    HLS_METAPORT;

    typedef hl5_block_1w1r::port_2< CYN::TLM, HLS_ACCESS,HLS_MAPPING>   this_type;
    typedef cynw_memory_ref< this_type, HLS_ACCESS,HLS_MAPPING > ref_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_port< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
    typedef sc_uint<10>                       address_type;
    typedef sc_uint<32>                      data_type;
    typedef unsigned int                          mask_type;

    port_2( const char* in_name=sc_gen_unique_name("port_2"), unsigned options_in=0 )
      : base_type(in_name), m_options(options_in)
    {
       m_tx_stream = 0;
       m_stream_name = (std::string("sc_main.") + std::string(this->name()));

	}

    CYNW_MEM_SQUARE_BRACKETS( ref_type )

    cynw_scv_memory_tx_stream< address_type, data_type >* tx_stream()
    {
#if !STRATUS
      if (m_tx_stream == 0) {
        esc_enable_scv_logging();
        m_tx_stream = new cynw_scv_memory_tx_stream< address_type, data_type >( m_stream_name.c_str(), esc_get_scv_tr_db() );
	  }
      return m_tx_stream;
#else
      return 0;
#endif
    }

  public:

    void nb_get_start( const address_type& address )
	{
		m_val = get(address);
	}

    bool nb_get( data_type& val )
    {

        val = m_val;
		return true;
    }

	sc_event_finder& value_changed()
	{
        return *(new sc_event_finder_t<cynw_memory_if< sc_uint<10>, sc_uint<32> > >(*this));
	}
    data_type get( const address_type& address )
    {

		data_type data = (*this)->get(address);
        this->tx_stream()->gen_read_tx( address, data );
        return data;
    }

    void put( const address_type& address, const data_type& data )
    {
        if ( (m_options & HLS::HLS_INTERNAL_ONLY) == 0) {
		  printf("WARNING: %s: Attempting to write to a read-only memory port\n", name());
        } else {
          (*this)->put(address,data);
        }
    }

    void nb_put( const address_type& address, const data_type& data )
    {
        (*this)->put(address,data);
    }
    

	void nb_deassert()
    {
    }

    void reset(  bool control_only=true )
    {
    }

  public:
    unsigned m_options;
    data_type m_val;
    cynw_scv_memory_tx_stream< address_type, data_type >* m_tx_stream;
    std::string m_stream_name;
};
#endif



#if !defined(STRATUS_VLG)
//
// TLM export metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <>
class hl5_block_1w1r::ex_port_2<CYN::TLM>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > >
{
  public:
    typedef hl5_block_1w1r::ex_port_2< CYN::TLM>   this_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    ex_port_2( const char* name=0, unsigned options_in=0 )
      : base_type(name)
    {}

  public:

};
#endif


#if !defined(STRATUS_VLG)
//
// TLM registered export metaport.
//
// Select this version by setting the HLS_L template argument to TLM.
//
template <>
class hl5_block_1w1r::reg_ex_port_2<CYN::TLM>
  : public hl5_block_1w1r::types<CYN::TLM>,
    public sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > >,
	public cynw_clk_rst_facade
{
  public:
    typedef hl5_block_1w1r::reg_ex_port_2< CYN::TLM>   this_type;
    typedef hl5_block_1w1r::types<CYN::TLM>     types;
    typedef sc_export< cynw_memory_if< sc_uint<10>, sc_uint<32> > > base_type;
   typedef sc_uint<10>                       address_type;
   typedef sc_uint<32>                      data_type;

    reg_ex_port_2( const char* name=0, unsigned options_in=0 )
      : base_type(name)
    {}

  public:
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport with stalling support.
//  
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::stall_port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
{   
  public:
    typedef hl5_block_1w1r::port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  base_type;
        
    stall_port_2( const char* name=0, unsigned options_in=0 )
      : base_type(name,options_in)
    {   
    }
};
#endif


#if !defined(STRATUS_VLG)
//
// TLM metaport with stalling support.
//  
// Select this version by either omitting the HLS_L template argument,
// or by setting it to PIN.
//
template <typename HLS_ACCESS,HLS::HLS_INDEX_MAPPING_OPTIONS HLS_MAPPING>
class hl5_block_1w1r::reg_port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
  : public hl5_block_1w1r::port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>
{   
  public:
    typedef hl5_block_1w1r::port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  base_type;
    typedef hl5_block_1w1r::reg_port_2<CYN::TLM,HLS_ACCESS,HLS_MAPPING>  this_type;
        
    reg_port_2( const char* name=0, unsigned options_in=0 )
      : base_type(name,options_in), if_inner(*this)
    {   
    }

	this_type& if_inner;
	
};
#endif


#if !defined(STRATUS_VLG) && !defined(STRATUS_HLS)

//
// Simple external memory wrapper.
//
// TLM version.
// Select this version by setting the HLS_L template argument to TLM.
// 
template <>
class hl5_block_1w1r::wrapper<CYN::TLM> :
    public sc_module,
    public hl5_block_1w1r::types<CYN::TLM>,
    public cynw_memory_if< sc_uint<10>, sc_uint<32> >
{
  public:
    typedef hl5_block_1w1r::wrapper<CYN::TLM>				this_type;
    typedef sc_uint<10>						    address_type;
    typedef sc_uint<32>						    data_type;
    typedef cynw_memory_if< address_type, data_type >   if_type;
  public:
    SC_HAS_PROCESS(wrapper);
    wrapper( sc_module_name in_name=sc_module_name( sc_gen_unique_name("hl5_block_1w1r")) )
	  : sc_module(in_name)
      ,CLK("CLK") 
, if1(*this)
, if2(*this)

      , model(basename()) 
	{
	}
    template <class T0,class T1>
    void clk_rst( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_async( T0 & CLK_in, T1 & rst_in, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_in<bool> & arst, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_signal<bool> & arst, bool rah=false )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_in<bool> & arst, bool rah, bool arah )
    {
        CLK(CLK_in);
    }
    template <class T0,class T1>
    void clk_rst_sync_async( T0 & CLK_in,T1 & rst_in, sc_signal<bool> & arst, bool rah, bool arah )
    {
        CLK(CLK_in);
    }
    template <class T0>
    void clk_rst( T0 & CLK_in )
    {
        CLK(CLK_in);
    }

    data_type get( const address_type& address )
    {
        return model.get(address);
    }

    void put( const address_type& address, const data_type& data )
    {
        model.put(address,data);
    }
  public:
    //
    // Ports.
    //
    sc_in_clk CLK;
    if_type& if1;
    if_type& if2;


    // 
    // The memory model.
    //
    hl5_block_1w1r_untimed_model model;
};

#endif // STRATUS_VLG
#endif // hl5_block_1w1r_H


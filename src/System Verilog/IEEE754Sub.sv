//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: ieee754_subtractor ()
//
module ieee754_subtractor // "top"
(
    input logic [31:0] a,
    input logic [31:0] b,
    input logic enable,
    output logic [31:0] ans
);

always_comb begin : compute
    logic [31:0] val_b;
    logic [31:0] val_s;
    logic [31:0] result;
    logic [23:0] aligned;
    logic [24:0] sum;
    logic [24:0] sum_norm;
    logic [4:0] lead0;
    logic sig_a;
    logic sig_b;
    logic result_sign;
    
    // Initialize all variables
    val_b = 0;
    val_s = 0;
    result = 0;
    aligned = 0;
    sum = 0;
    sum_norm = 0;
    lead0 = 0;
    sig_a = 0;
    sig_b = 0;
    result_sign = 0;

    if (enable) begin
        sig_a = a[31];
        sig_b = !b[31];  // Flip sign for subtraction
        
        // Determine larger and smaller operands
        if (a[30:0] > b[30:0]) begin
            val_b = a;
            val_s = b;
            result_sign = sig_a;
        end else begin
            val_b = b;
            val_s = a;
            result_sign = sig_b;
        end

        // Align mantissas
        aligned = (24'd1 << 23) | val_s[22:0];
        aligned = aligned >>> (val_b[30:23] - val_s[30:23]);

        // Perform addition or subtraction of mantissas
        if (sig_a == sig_b) begin
            sum = (25'd1 << 23) | val_b[22:0];
            sum = sum + aligned;
        end else begin
            sum = (25'd1 << 23) | val_b[22:0];
            sum = sum - aligned;
        end

        // Handle zero result
        if (sum == 0) begin
            result = 0;
        end else begin
            // Count leading zeros for normalization
            for (integer i = 23; i >= 0; --i) begin
                if (sum[i]) begin
                    lead0 = 23 - i;
                    break;
                end
            end

            sum_norm = sum << lead0;

            // Normalize result
            if (sum[24]) begin  // Overflow case
                result[30:23] = val_b[30:23] + 1;
                result[22:0] = sum[23:1];
            end else begin
                if (lead0 > val_b[30:23]) begin  // Underflow case
                    result = 0;
                end else begin  // Normal case
                    result[30:23] = val_b[30:23] - lead0;
                    result[22:0] = sum_norm[22:0];
                end
            end
            result[31] = result_sign;
        end
        ans = result;
    end else begin
        ans = 0;
    end
end

endmodule
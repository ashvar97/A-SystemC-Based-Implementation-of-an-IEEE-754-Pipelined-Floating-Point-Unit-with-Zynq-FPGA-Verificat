//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: ieee754_divider ()
//
module ieee754_divider // "top"
(
    input logic [31:0] dividend,
    input logic [31:0] divisor,
    input logic reset,
    output logic [31:0] result,
    output logic normalized
);

// Signal declarations
logic [31:0] dividend_sig;
logic [31:0] divisor_sig;
logic dividend_sign;
logic divisor_sign;
logic [7:0] dividend_exp;
logic [7:0] divisor_exp;

//------------------------------------------------------------------------------
// Sub-module instances

ieee754_extractor extractor(
    .a(dividend),
    .b(divisor),
    .reset(reset),
    .a_significand(dividend_sig),
    .b_significand(divisor_sig),
    .a_sign(dividend_sign),
    .b_sign(divisor_sign),
    .a_exp(dividend_exp),
    .b_exp(divisor_exp)
);

ieee754_division_core divider(
    .dividend_sig(dividend_sig),
    .divisor_sig(divisor_sig),
    .dividend_sign(dividend_sign),
    .divisor_sign(divisor_sign),
    .dividend_exp(dividend_exp),
    .divisor_exp(divisor_exp),
    .reset(reset),
    .result(result)
);

ieee754_normalization_checker normal_checker(
    .result(result),
    .a_exp(dividend_exp),
    .reset(reset),
    .normalized(normalized)
);

endmodule

//==============================================================================
//
// Module: ieee754_extractor ()
//
module ieee754_extractor // "top.extractor"
(
    input logic [31:0] a,
    input logic [31:0] b,
    input logic reset,
    output logic [31:0] a_significand,
    output logic [31:0] b_significand,
    output logic a_sign,
    output logic b_sign,
    output logic [7:0] a_exp,
    output logic [7:0] b_exp
);

always_comb begin : extract
    if (reset) begin
        a_significand = 0;
        b_significand = 0;
        a_sign = 0;
        b_sign = 0;
        a_exp = 0;
        b_exp = 0;
    end else begin
        // Extract exponents (8 bits)
        a_exp = (a & 32'h7F800000) >> 23;
        b_exp = (b & 32'h7F800000) >> 23;
        
        // Extract signs
        a_sign = a[31];
        b_sign = b[31];
        
        // Extract and normalize significands (add implicit leading 1)
        a_significand = (a & 32'h007FFFFF) | 32'h00800000;
        b_significand = (b & 32'h007FFFFF) | 32'h00800000;
    end
end

endmodule

//==============================================================================
//
// Module: ieee754_division_core ()
//
module ieee754_division_core // "top.divider"
(
    input logic [31:0] dividend_sig,
    input logic [31:0] divisor_sig,
    input logic dividend_sign,
    input logic divisor_sign,
    input logic [7:0] dividend_exp,
    input logic [7:0] divisor_exp,
    input logic reset,
    output logic [31:0] result
);

always_comb begin : compute
    logic [31:0] quotient;
    logic [7:0] result_exp;
    logic [4:0] i;
    logic odd;
    logic rnd;
    logic sticky;
    logic [31:0] x_val;
    logic [31:0] y_val;
    logic [7:0] shift;
    logic result_sign;
    
    // Initialize variables
    quotient = 0;
    result_exp = 0;
    i = 0;
    odd = 0;
    rnd = 0;
    sticky = 0;
    x_val = 0;
    y_val = 0;
    shift = 0;
    result_sign = 0;

    if (reset) begin
        result = 0;
    end else begin
        // Determine result sign (XOR of input signs)
        result_sign = dividend_sign ^ divisor_sign;
        
        // Calculate result exponent (dividend_exp - divisor_exp + bias)
        result_exp = dividend_exp - divisor_exp + 8'd127;
        
        // Initialize values for division
        x_val = dividend_sig;
        y_val = divisor_sig;
        
        // Normalize dividend if smaller than divisor
        if (x_val < y_val) begin
            x_val = x_val << 1;
            result_exp = result_exp - 1;
        end
        
        // Perform division (restoring algorithm)
        for (i = 0; i < 25; i++) begin
            quotient = quotient << 1;
            if (x_val >= y_val) begin
                x_val = x_val - y_val;
                quotient = quotient | 1;
            end
            x_val = x_val << 1;
        end
        
        // Determine sticky bit (remainder != 0)
        sticky = x_val != 0;
        
        // Handle normal numbers
        if ((result_exp >= 1) && (result_exp <= 254)) begin
            rnd = (quotient & 32'h01000000) >> 24;  // Round bit
            odd = (quotient & 32'h00000002) != 0;   // Least significant bit
            quotient = (quotient >> 1) + (rnd & (sticky | odd));
            quotient = (result_exp << 23) + (quotient - 32'h00800000);
        end 
        // Handle overflow/underflow
        else begin
            if (result_exp > 254) begin  // Overflow
                quotient = 32'h7F800000;  // Infinity
            end else begin                // Underflow
                shift = 1 - result_exp;
                if (shift > 25) shift = 25;
                
                // Calculate sticky bit for denormal numbers
                sticky = sticky | ((quotient & ~(~0 << shift)) != 0;
                quotient = quotient >> shift;
                
                // Rounding
                rnd = (quotient & 32'h01000000) >> 24;
                odd = (quotient & 32'h00000002) != 0;
                quotient = (quotient >> 1) + (rnd & (sticky | odd));
            end
        end
        
        // Apply sign bit
        result = quotient | (result_sign ? 32'h80000000 : 0);
    end
end

endmodule

//==============================================================================
//
// Module: ieee754_normalization_checker ()
//
module ieee754_normalization_checker // "top.normal_checker"
(
    input logic [31:0] result,
    input logic [7:0] a_exp,
    input logic reset,
    output logic normalized
);

always_comb begin : normalize
    if (reset) begin
        normalized = 0;
    end else begin
        // Check for infinity/NaN or zero/subnormal
        if ((result & 32'h7F800000) == 32'h7F800000 ||  // Infinity/NaN
            (result & 32'h7F800000) == 0) begin        // Zero/subnormal
            normalized = 0;
        end else begin
            normalized = 1;
        end
    end
end

endmodule
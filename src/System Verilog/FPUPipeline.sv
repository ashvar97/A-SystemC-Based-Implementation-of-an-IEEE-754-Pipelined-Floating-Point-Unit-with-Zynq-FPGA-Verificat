//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: FpSystem ()
//
module FpSystem // "system"
(
    input logic clk,
    input logic reset,
    input logic stall,
    output logic monitor_valid,
    output logic [7:0] monitor_pc
);

// Variables generated for SystemC signals
logic internal_stall;
logic [31:0] pc_out;
logic [31:0] ifu_instruction_out;
logic ifu_valid_out;
logic [31:0] op1_out;
logic [31:0] op2_out;
logic [4:0] rd_out;
logic reg_write_out;
logic decode_valid_out;
logic [31:0] decode_instruction_out;
logic [6:0] opcode;
logic [31:0] ex_result_out;
logic [4:0] ex_rd_out;
logic ex_reg_write_out;
logic ex_valid_out;
logic [31:0] ex_instruction_out;
logic [31:0] mem_result_out;
logic [4:0] mem_rd_out;
logic mem_reg_write_out;
logic mem_valid_out;
logic [31:0] mem_instruction_out;
logic [31:0] wb_result_out;
logic [4:0] wb_rd_out;
logic wb_reg_write_en;
logic wb_valid_out;
logic [31:0] reg_file[32];
logic [31:0] imem_address;
logic [31:0] imem_instruction;

//------------------------------------------------------------------------------
// Method process: update_stall (example.cpp:71:5) 

always_comb 
begin : update_stall     // example.cpp:71:5
    internal_stall = stall;
end

//------------------------------------------------------------------------------
// Method process: update_opcode (example.cpp:66:5) 

always_comb 
begin : update_opcode     // example.cpp:66:5
    opcode = decode_instruction_out[31 : 25];
end

//------------------------------------------------------------------------------
// Method process: update_monitor (example.cpp:210:5) 

always_comb 
begin : update_monitor     // example.cpp:210:5
    monitor_valid = wb_valid_out;
    monitor_pc = pc_out[7 : 0];
end

//------------------------------------------------------------------------------
// Clocked THREAD: ifu_process (example.cpp:75:5) 

// Thread-local variables
logic terminated;
logic terminated_next;
logic [31:0] pc;
logic [31:0] pc_next;
logic [31:0] ifu_instruction_out_next;
logic ifu_valid_out_next;
logic [31:0] pc_out_next;
logic [31:0] imem_address_next;

// Next-state combinational logic
always_comb begin : ifu_process_comb     // example.cpp:75:5
    ifu_process_func;
end
function void ifu_process_func;
    logic [31:0] current_pc;
    logic [31:0] instruction;
    ifu_instruction_out_next = ifu_instruction_out;
    ifu_valid_out_next = ifu_valid_out;
    imem_address_next = imem_address;
    pc_next = pc;
    pc_out_next = pc_out;
    terminated_next = terminated;
    if (reset)
    begin
        pc_next = 0;
        terminated_next = 0;
        ifu_instruction_out_next = 0;
        ifu_valid_out_next = 0;
        pc_out_next = 0;
        imem_address_next = 0;
    end else begin
        if (!internal_stall && !terminated_next)
        begin
            current_pc = pc_next;
            imem_address_next = current_pc;
            instruction = imem_instruction;
            ifu_instruction_out_next = instruction;
            ifu_valid_out_next = instruction != 0;
            pc_out_next = current_pc;
            if (instruction == 0)
            begin
                terminated_next = 1;
                ifu_valid_out_next = 0;
            end else begin
                pc_next = current_pc + 4;
            end
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync reset*/) 
begin : ifu_process_ff
    if ( reset ) begin
        logic [31:0] current_pc;
        logic [31:0] instruction;
        pc <= 0;
        terminated <= 0;
        ifu_instruction_out <= 0;
        ifu_valid_out <= 0;
        pc_out <= 0;
        imem_address <= 0;
        if (reset)
        begin
            pc <= 0;
            terminated <= 0;
            ifu_instruction_out <= 0;
            ifu_valid_out <= 0;
            pc_out <= 0;
            imem_address <= 0;
        end else begin
            if (!internal_stall && !terminated)
            begin
                current_pc = pc;
                imem_address <= current_pc;
                instruction = imem_instruction;
                ifu_instruction_out <= instruction;
                ifu_valid_out <= instruction != 0;
                pc_out <= current_pc;
                if (instruction == 0)
                begin
                    terminated <= 1;
                    ifu_valid_out <= 0;
                end else begin
                    pc <= current_pc + 4;
                end
            end
        end
    end
    else begin
        terminated <= terminated_next;
        pc <= pc_next;
        ifu_instruction_out <= ifu_instruction_out_next;
        ifu_valid_out <= ifu_valid_out_next;
        pc_out <= pc_out_next;
        imem_address <= imem_address_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: decode_process (example.cpp:140:5) 

// Thread-local variables
logic [31:0] op1_out_next;
logic [31:0] op2_out_next;
logic [4:0] rd_out_next;
logic reg_write_out_next;
logic decode_valid_out_next;
logic [31:0] decode_instruction_out_next;

// Next-state combinational logic
always_comb begin : decode_process_comb     // example.cpp:140:5
    decode_process_func;
end
function void decode_process_func;
    logic [4:0] rs1;
    logic [4:0] rs2;
    logic [4:0] rd;
    decode_instruction_out_next = decode_instruction_out;
    decode_valid_out_next = decode_valid_out;
    op1_out_next = op1_out;
    op2_out_next = op2_out;
    rd_out_next = rd_out;
    reg_write_out_next = reg_write_out;
    if (reset)
    begin
        op1_out_next = 0;
        op2_out_next = 0;
        rd_out_next = 0;
        reg_write_out_next = 0;
        decode_valid_out_next = 0;
        decode_instruction_out_next = 0;
    end else begin
        if (!internal_stall)
        begin
            decode_valid_out_next = ifu_valid_out;
            decode_instruction_out_next = ifu_instruction_out;
            if (ifu_valid_out && ifu_instruction_out != 0)
            begin
                rs1 = (ifu_instruction_out >>> 15) & 'h1F;
                rs2 = (ifu_instruction_out >>> 20) & 'h1F;
                rd = (ifu_instruction_out >>> 7) & 'h1F;
                op1_out_next = reg_file[32'(rs1)];
                op2_out_next = reg_file[32'(rs2)];
                rd_out_next = rd;
                reg_write_out_next = 1;
            end else begin
                op1_out_next = 0;
                op2_out_next = 0;
                rd_out_next = 0;
                reg_write_out_next = 0;
            end
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync reset*/) 
begin : decode_process_ff
    if ( reset ) begin
        logic [4:0] rs1;
        logic [4:0] rs2;
        logic [4:0] rd;
        op1_out <= 0;
        op2_out <= 0;
        rd_out <= 0;
        reg_write_out <= 0;
        decode_valid_out <= 0;
        decode_instruction_out <= 0;
        if (reset)
        begin
            op1_out <= 0;
            op2_out <= 0;
            rd_out <= 0;
            reg_write_out <= 0;
            decode_valid_out <= 0;
            decode_instruction_out <= 0;
        end else begin
            if (!internal_stall)
            begin
                decode_valid_out <= ifu_valid_out;
                decode_instruction_out <= ifu_instruction_out;
                if (ifu_valid_out && ifu_instruction_out != 0)
                begin
                    rs1 = (ifu_instruction_out >>> 15) & 'h1F;
                    rs2 = (ifu_instruction_out >>> 20) & 'h1F;
                    rd = (ifu_instruction_out >>> 7) & 'h1F;
                    op1_out <= reg_file[32'(rs1)];
                    op2_out <= reg_file[32'(rs2)];
                    rd_out <= rd;
                    reg_write_out <= 1;
                end else begin
                    op1_out <= 0;
                    op2_out <= 0;
                    rd_out <= 0;
                    reg_write_out <= 0;
                end
            end
        end
    end
    else begin
        op1_out <= op1_out_next;
        op2_out <= op2_out_next;
        rd_out <= rd_out_next;
        reg_write_out <= reg_write_out_next;
        decode_valid_out <= decode_valid_out_next;
        decode_instruction_out <= decode_instruction_out_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: reg_file_update (example.cpp:193:5) 

// Thread-local variables
logic [31:0] reg_file_next[32];

// Next-state combinational logic
always_comb begin : reg_file_update_comb     // example.cpp:193:5
    reg_file_update_func;
end
function void reg_file_update_func;
    integer unsigned rd_index;
    reg_file_next = reg_file;
    if (reset)
    begin
    end else begin
        if (wb_reg_write_en && wb_valid_out)
        begin
            rd_index = 32'(wb_rd_out);
            if (rd_index < 32)
            begin
                reg_file_next[rd_index] = wb_result_out;
            end
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync reset*/) 
begin : reg_file_update_ff
    if ( reset ) begin
        integer unsigned rd_index;
        if (reset)
        begin
        end else begin
            if (wb_reg_write_en && wb_valid_out)
            begin
                rd_index = 32'(wb_rd_out);
                if (rd_index < 32)
                begin
                    reg_file[rd_index] <= wb_result_out;
                end
            end
        end
    end
    else begin
        reg_file <= reg_file_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

InstructionMemory imem
(
  .address(imem_address),
  .instruction(imem_instruction)
);

Execute execute
(
  .clk(clk),
  .reset(reset),
  .stall(internal_stall),
  .valid_in(decode_valid_out),
  .op1(op1_out),
  .op2(op2_out),
  .opcode(opcode),
  .rd_in(rd_out),
  .reg_write_in(reg_write_out),
  .instruction_in(decode_instruction_out),
  .result_out(ex_result_out),
  .rd_out(ex_rd_out),
  .reg_write_out(ex_reg_write_out),
  .valid_out(ex_valid_out),
  .instruction_out(ex_instruction_out)
);

Memory memory
(
  .reset(reset),
  .stall(internal_stall),
  .valid_in(ex_valid_out),
  .result_in(ex_result_out),
  .rd_in(ex_rd_out),
  .reg_write_in(ex_reg_write_out),
  .instruction_in(ex_instruction_out),
  .result_out(mem_result_out),
  .rd_out(mem_rd_out),
  .reg_write_out(mem_reg_write_out),
  .valid_out(mem_valid_out),
  .instruction_out(mem_instruction_out)
);

Writeback writeback
(
  .reset(reset),
  .stall(internal_stall),
  .valid_in(mem_valid_out),
  .result_in(mem_result_out),
  .rd_in(mem_rd_out),
  .reg_write_in(mem_reg_write_out),
  .instruction_in(mem_instruction_out),
  .result_out(wb_result_out),
  .rd_out(wb_rd_out),
  .reg_write_en(wb_reg_write_en),
  .valid_out(wb_valid_out)
);

endmodule



//==============================================================================
//
// Module: InstructionMemory (example.cpp:61:5)
//
module InstructionMemory // "system.instruction_memory"
(
    input logic [31:0] address,
    output logic [31:0] instruction
);

// Variables generated for SystemC signals
logic [31:0] imem[256];

//------------------------------------------------------------------------------
// Method process: process_read (imem.h:9:5) 

always_comb 
begin : process_read     // imem.h:9:5
    instruction = imem[address[9 : 2]];
end

endmodule



//==============================================================================
//
// Module: Execute (example.cpp:62:5)
//
module Execute // "system.execute"
(
    input logic clk,
    input logic reset,
    input logic stall,
    input logic valid_in,
    input logic [31:0] op1,
    input logic [31:0] op2,
    input logic [6:0] opcode,
    input logic [4:0] rd_in,
    input logic reg_write_in,
    input logic [31:0] instruction_in,
    output logic [31:0] result_out,
    output logic [4:0] rd_out,
    output logic reg_write_out,
    output logic valid_out,
    output logic [31:0] instruction_out
);

// Variables generated for SystemC signals
logic [31:0] fp_add_result;
logic [31:0] fp_sub_result;
logic [31:0] fp_mul_result;
logic [31:0] fp_div_result;
logic sub_enable;

//------------------------------------------------------------------------------
// Clocked THREAD: execute_process (execute.h:34:5) 

// Thread-local variables
logic [31:0] result_out_next;
logic [4:0] rd_out_next;
logic reg_write_out_next;
logic valid_out_next;
logic [31:0] instruction_out_next;

// Next-state combinational logic
always_comb begin : execute_process_comb     // execute.h:34:5
    execute_process_func;
end
function void execute_process_func;
    instruction_out_next = instruction_out;
    rd_out_next = rd_out;
    reg_write_out_next = reg_write_out;
    result_out_next = result_out;
    valid_out_next = valid_out;
    if (reset)
    begin
        result_out_next = 0;
        rd_out_next = 0;
        reg_write_out_next = 0;
        valid_out_next = 0;
        instruction_out_next = 0;
    end else begin
        if (!stall)
        begin
            valid_out_next = valid_in;
            rd_out_next = rd_in;
            reg_write_out_next = reg_write_in;
            instruction_out_next = instruction_in;
            if (valid_in && reg_write_in)
            begin
                case (opcode)
                0 : begin
                    result_out_next = fp_add_result;
                end
                4 : begin
                    result_out_next = fp_sub_result;
                end
                8 : begin
                    result_out_next = fp_mul_result;
                end
                12 : begin
                    result_out_next = fp_div_result;
                end
                default : begin
                    result_out_next = 0;
                end
                endcase
            end
        end
    end
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync reset*/) 
begin : execute_process_ff
    if ( reset ) begin
        sub_enable <= 1;
    end
    else begin
        result_out <= result_out_next;
        rd_out <= rd_out_next;
        reg_write_out <= reg_write_out_next;
        valid_out <= valid_out_next;
        instruction_out <= instruction_out_next;
    end
end


//------------------------------------------------------------------------------
// Child module instances

ieee754_adder fp_adder
(
  .A(op1),
  .B(op2),
  .O(fp_add_result)
);

ieee754_subtractor fp_subtractor
(
  .a(op1),
  .b(op2),
  .enable(sub_enable),
  .ans(fp_sub_result)
);

ieee754mult fp_multiplier
(
  .A(op1),
  .B(op2),
  .reset(reset),
  .result(fp_mul_result)
);

ieee754_div fp_divider
(
  .a(op1),
  .b(op2),
  .reset(reset),
  .result(fp_div_result)
);

endmodule



//==============================================================================
//
// Module: ieee754_adder ()
//
module ieee754_adder // "system.execute.fp_adder"
(
    input logic [31:0] A,
    input logic [31:0] B,
    output logic [31:0] O
);

// Variables generated for SystemC signals
logic sign_a;
logic sign_b;
logic out_sign;
logic [7:0] exp_a;
logic [7:0] exp_b;
logic [7:0] out_exponent;
logic [23:0] mant_a;
logic [23:0] mant_b;
logic [24:0] out_mantissa;


//------------------------------------------------------------------------------
// Child module instances

ieee754_extractor extractA
(
  .A(A),
  .sign(sign_a),
  .exponent(exp_a),
  .mantissa(mant_a)
);

ieee754_extractor extractB
(
  .A(B),
  .sign(sign_b),
  .exponent(exp_b),
  .mantissa(mant_b)
);

ieee754_adder_core adderCore
(
  .exp_a(exp_a),
  .exp_b(exp_b),
  .mant_a(mant_a),
  .mant_b(mant_b),
  .sign_a(sign_a),
  .sign_b(sign_b),
  .out_sign(out_sign),
  .out_exponent(out_exponent),
  .out_mantissa(out_mantissa)
);

ieee754_normalizer normalizer
(
  .exponent(out_exponent),
  .mantissa(out_mantissa),
  .sign(out_sign),
  .result(O)
);

endmodule



//==============================================================================
//
// Module: ieee754_extractor ()
//
module ieee754_extractor // "system.execute.fp_adder.extractA"
(
    input logic [31:0] A,
    output logic sign,
    output logic [7:0] exponent,
    output logic [23:0] mantissa
);

//------------------------------------------------------------------------------
// Method process: process (IEEE754Add.h:14:5) 

always_comb 
begin : process     // IEEE754Add.h:14:5
    sign = A[31];
    exponent = A[30 : 23];
    if (exponent == 0)
    begin
        mantissa = 24'({1'd0, A[22 : 0]});
    end else begin
        mantissa = 24'({1'd1, A[22 : 0]});
    end
end

endmodule



//==============================================================================
//
// Module: ieee754_adder_core ()
//
module ieee754_adder_core // "system.execute.fp_adder.adderCore"
(
    input logic [7:0] exp_a,
    input logic [7:0] exp_b,
    input logic [23:0] mant_a,
    input logic [23:0] mant_b,
    input logic sign_a,
    input logic sign_b,
    output logic out_sign,
    output logic [7:0] out_exponent,
    output logic [24:0] out_mantissa
);

//------------------------------------------------------------------------------
// Method process: process (IEEE754Add.h:43:5) 

always_comb 
begin : process     // IEEE754Add.h:43:5
    logic [7:0] diff;
    logic [23:0] tmp_mantissa;
    logic a_is_nan;
    logic b_is_nan;
    logic a_is_inf;
    logic b_is_inf;
    diff = 0;
    tmp_mantissa = 0;
    a_is_nan = (exp_a == 'hFF) && (mant_a[22 : 0] != 0);
    b_is_nan = (exp_b == 'hFF) && (mant_b[22 : 0] != 0);
    a_is_inf = (exp_a == 'hFF) && (mant_a[22 : 0] == 0);
    b_is_inf = (exp_b == 'hFF) && (mant_b[22 : 0] == 0);
    if (a_is_nan || b_is_nan)
    begin
        out_exponent = 'hFF;
        out_mantissa = 'h400000;
        out_sign = 0;
    end else begin
        if (a_is_inf || b_is_inf)
        begin
            if (a_is_inf && b_is_inf)
            begin
                if (sign_a == sign_b)
                begin
                    out_exponent = 'hFF;
                    out_mantissa = 0;
                    out_sign = sign_a;
                end else begin
                    out_exponent = 'hFF;
                    out_mantissa = 'h400000;
                    out_sign = 0;
                end
            end else begin
                out_exponent = 'hFF;
                out_mantissa = 0;
                out_sign = a_is_inf ? sign_a : sign_b;
            end
        end else begin
            if (exp_a == 0 && mant_a == 0)
            begin
                out_sign = sign_b;
                out_exponent = exp_b;
                out_mantissa = 25'({1'd0, mant_b});
            end else begin
                if (exp_b == 0 && mant_b == 0)
                begin
                    out_sign = sign_a;
                    out_exponent = exp_a;
                    out_mantissa = 25'({1'd0, mant_a});
                end else begin
                    if (exp_a == 0)
                    begin
                        out_exponent = exp_b;
                        tmp_mantissa = mant_a;
                    end else begin
                        if (exp_b == 0)
                        begin
                            out_exponent = exp_a;
                            tmp_mantissa = mant_b;
                        end else begin
                            out_exponent = (exp_a > exp_b) ? exp_a : exp_b;
                        end
                    end
                    if (exp_a > exp_b)
                    begin
                        diff = exp_a - exp_b;
                        tmp_mantissa = mant_b >>> diff;
                        if (sign_a == sign_b)
                        begin
                            out_mantissa = 25'({1'd0, mant_a}) + 25'({1'd0, tmp_mantissa});
                        end else begin
                            if (mant_a >= tmp_mantissa)
                            begin
                                out_mantissa = 25'({1'd0, mant_a}) - 25'({1'd0, tmp_mantissa});
                            end else begin
                                out_mantissa = 25'({1'd0, tmp_mantissa}) - 25'({1'd0, mant_a});
                            end
                        end
                        out_sign = (mant_a >= tmp_mantissa) ? sign_a : sign_b;
                    end else begin
                        if (exp_b > exp_a)
                        begin
                            diff = exp_b - exp_a;
                            tmp_mantissa = mant_a >>> diff;
                            if (sign_a == sign_b)
                            begin
                                out_mantissa = 25'({1'd0, mant_b}) + 25'({1'd0, tmp_mantissa});
                            end else begin
                                if (mant_b >= tmp_mantissa)
                                begin
                                    out_mantissa = 25'({1'd0, mant_b}) - 25'({1'd0, tmp_mantissa});
                                end else begin
                                    out_mantissa = 25'({1'd0, tmp_mantissa}) - 25'({1'd0, mant_b});
                                end
                            end
                            out_sign = (mant_b >= tmp_mantissa) ? sign_b : sign_a;
                        end else begin
                            if (sign_a == sign_b)
                            begin
                                out_mantissa = 25'({1'd0, mant_a}) + 25'({1'd0, mant_b});
                            end else begin
                                if (mant_a > mant_b)
                                begin
                                    out_mantissa = 25'({1'd0, mant_a}) - 25'({1'd0, mant_b});
                                end else begin
                                    out_mantissa = 25'({1'd0, mant_b}) - 25'({1'd0, mant_a});
                                end
                            end
                            out_sign = (mant_a > mant_b) ? sign_a : sign_b;
                        end
                    end
                    if (out_mantissa == 0)
                    begin
                        out_sign = 0;
                        out_exponent = 0;
                    end
                end
            end
        end
    end
end

endmodule



//==============================================================================
//
// Module: ieee754_normalizer ()
//
module ieee754_normalizer // "system.execute.fp_adder.normalizer"
(
    input logic [7:0] exponent,
    input logic [24:0] mantissa,
    input logic sign,
    output logic [31:0] result
);

//------------------------------------------------------------------------------
// Method process: process (IEEE754Add.h:166:5) 

always_comb 
begin : process     // IEEE754Add.h:166:5
    logic [4:0] lz;
    logic [7:0] norm_exponent;
    logic [24:0] norm_mantissa;
    lz = 0;
    norm_exponent = 0;
    norm_mantissa = 0;
    if (exponent == 'hFF)
    begin
        result = 32'({sign, exponent, mantissa[22 : 0]});
    end else begin
        if (mantissa == 0)
        begin
            result = 0;
        end else begin
            norm_exponent = exponent;
            norm_mantissa = mantissa;
            if (norm_mantissa[24])
            begin
                norm_exponent = norm_exponent + 1;
                norm_mantissa = norm_mantissa >>> 1;
            end else begin
                if (norm_mantissa[23] == 0 && norm_exponent != 0)
                begin
                    for (lz = 0; lz < 24 && norm_mantissa[23 - lz] == 0; lz++)
                    begin
                    end
                    if (norm_exponent > lz)
                    begin
                        norm_exponent = norm_exponent - lz;
                        norm_mantissa = norm_mantissa <<< lz;
                    end else begin
                        norm_mantissa = norm_mantissa <<< 9'(norm_exponent - 1);
                        norm_exponent = 0;
                    end
                end
            end
            if (norm_exponent >= 'hFF)
            begin
                result = 0;
            end else begin
                result = 32'({sign, norm_exponent, norm_mantissa[22 : 0]});
            end
        end
    end
end

endmodule



//==============================================================================
//
// Module: ieee754_subtractor ()
//
module ieee754_subtractor // "system.execute.fp_subtractor"
(
    input logic [31:0] a,
    input logic [31:0] b,
    input logic enable,
    output logic [31:0] ans
);

//------------------------------------------------------------------------------
// Method process: compute (IEEE754Sub.h:11:5) 

always_comb 
begin : compute     // IEEE754Sub.h:11:5
    logic [31:0] val_b;
    logic [31:0] val_s;
    logic [31:0] result;
    logic [23:0] aligned;
    logic [24:0] sum;
    logic [24:0] sum_norm;
    logic [4:0] lead0;
    logic sig_a;
    logic sig_b;
    logic result_sign;
    val_b = 0;
    val_s = 0;
    result = 0;
    aligned = 0;
    sum = 0;
    sum_norm = 0;
    lead0 = 0;
    sig_a = 0;
    sig_b = 0;
    result_sign = 0;
    if (enable)
    begin
        val_b = 0;
        val_s = 0;
        result = 0;
        aligned = 0;
        sum = 0;
        sum_norm = 0;
        lead0 = 0;
        sig_a = a[31];
        sig_b = !b[31];
        if (a[30 : 0] > b[30 : 0])
        begin
            val_b = a;
            val_s = b;
            result_sign = sig_a;
        end else begin
            val_b = b;
            val_s = a;
            result_sign = sig_b;
        end
        aligned = (24'd1 <<< 23) | val_s[22 : 0];
        aligned = aligned >>> (9'(val_b[30 : 23] - val_s[30 : 23]));
        if (sig_a == sig_b)
        begin
            sum = (25'd1 <<< 23) | val_b[22 : 0];
            sum = sum + aligned;
        end else begin
            sum = (25'd1 <<< 23) | val_b[22 : 0];
            sum = sum - aligned;
        end
        if (sum == 0)
        begin
            result = 0;
        end else begin
            for (integer i = 23; i >= 0; --i)
            begin
                if (sum[i])
                begin
                    lead0 = 23 - i;
                    break;
                end
            end
            sum_norm = sum <<< lead0;
            if (sum[24])
            begin
                result[30 : 23] = val_b[30 : 23] + 1;
                result[22 : 0] = sum[23 : 1];
            end else begin
                if (lead0 > val_b[30 : 23])
                begin
                    result = 0;
                end else begin
                    result[30 : 23] = val_b[30 : 23] - lead0;
                    result[22 : 0] = sum_norm[22 : 0];
                end
            end
            result[31] = result_sign;
        end
        ans = result;
    end else begin
        ans = 0;
    end
end

endmodule



//==============================================================================
//
// Module: ieee754mult ()
//
module ieee754mult // "system.execute.fp_multiplier"
(
    input logic [31:0] A,
    input logic [31:0] B,
    input logic reset,
    output logic [31:0] result
);

// Variables generated for SystemC signals
logic A_sign;
logic B_sign;
logic Sign;
logic [7:0] A_Exponent;
logic [7:0] B_Exponent;
logic [7:0] Temp_Exponent;
logic [23:0] A_Mantissa;
logic [23:0] B_Mantissa;
logic [47:0] Temp_Mantissa;


//------------------------------------------------------------------------------
// Child module instances

FloatingPointExtractor extractA
(
  .in(A),
  .reset(reset),
  .sign(A_sign),
  .exponent(A_Exponent),
  .mantissa(A_Mantissa)
);

FloatingPointExtractor extractB
(
  .in(B),
  .reset(reset),
  .sign(B_sign),
  .exponent(B_Exponent),
  .mantissa(B_Mantissa)
);

FloatingPointMultiplier multiply
(
  .A_Mantissa(A_Mantissa),
  .B_Mantissa(B_Mantissa),
  .A_Exponent(A_Exponent),
  .B_Exponent(B_Exponent),
  .A_sign(A_sign),
  .B_sign(B_sign),
  .reset(reset),
  .Temp_Mantissa(Temp_Mantissa),
  .Temp_Exponent(Temp_Exponent),
  .Sign(Sign)
);

FloatingPointNormalizer normalize
(
  .Temp_Mantissa(Temp_Mantissa),
  .Temp_Exponent(Temp_Exponent),
  .Sign(Sign),
  .reset(reset),
  .result(result)
);

endmodule



//==============================================================================
//
// Module: FloatingPointExtractor (IEEE754Mult.h:113:5)
//
module FloatingPointExtractor // "system.execute.fp_multiplier.extractA"
(
    input logic [31:0] in,
    input logic reset,
    output logic sign,
    output logic [7:0] exponent,
    output logic [23:0] mantissa
);

//------------------------------------------------------------------------------
// Method process: extract (IEEE754Mult.h:16:5) 

always_comb 
begin : extract     // IEEE754Mult.h:16:5
    if (reset)
    begin
        sign = 0;
        exponent = 0;
        mantissa = 0;
    end else begin
        sign = in[31];
        exponent = in[30 : 23];
        mantissa = (24'd1 <<< 23) | in[22 : 0];
    end
end

endmodule



//==============================================================================
//
// Module: FloatingPointMultiplier (IEEE754Mult.h:115:5)
//
module FloatingPointMultiplier // "system.execute.fp_multiplier.multiply"
(
    input logic [23:0] A_Mantissa,
    input logic [23:0] B_Mantissa,
    input logic [7:0] A_Exponent,
    input logic [7:0] B_Exponent,
    input logic A_sign,
    input logic B_sign,
    input logic reset,
    output logic [47:0] Temp_Mantissa,
    output logic [7:0] Temp_Exponent,
    output logic Sign
);

//------------------------------------------------------------------------------
// Method process: multiply (IEEE754Mult.h:47:5) 

always_comb 
begin : multiply     // IEEE754Mult.h:47:5
    if (reset)
    begin
        Temp_Mantissa = 0;
        Temp_Exponent = 0;
        Sign = 0;
    end else begin
        Temp_Mantissa = A_Mantissa * B_Mantissa;
        Temp_Exponent = A_Exponent + B_Exponent - 127;
        Sign = A_sign ^ B_sign;
    end
end

endmodule



//==============================================================================
//
// Module: FloatingPointNormalizer (IEEE754Mult.h:116:5)
//
module FloatingPointNormalizer // "system.execute.fp_multiplier.normalize"
(
    input logic [47:0] Temp_Mantissa,
    input logic [7:0] Temp_Exponent,
    input logic Sign,
    input logic reset,
    output logic [31:0] result
);

//------------------------------------------------------------------------------
// Method process: normalize (IEEE754Mult.h:73:5) 

always_comb 
begin : normalize     // IEEE754Mult.h:73:5
    logic [22:0] Mantissa;
    logic [7:0] Exponent;
    Mantissa = 0;
    Exponent = 0;
    if (reset)
    begin
        result = 0;
    end else begin
        Mantissa = 0;
        Exponent = 0;
        if (Temp_Mantissa[47])
        begin
            Mantissa = Temp_Mantissa[46 : 24];
            Exponent = Temp_Exponent + 1;
        end else begin
            Mantissa = Temp_Mantissa[45 : 23];
            Exponent = Temp_Exponent;
        end
        result = {Sign, Exponent, Mantissa};
    end
end

endmodule



//==============================================================================
//
// Module: ieee754_div ()
//
module ieee754_div // "system.execute.fp_divider"
(
    input logic [31:0] a,
    input logic [31:0] b,
    input logic reset,
    output logic [31:0] result
);

// Variables generated for SystemC signals
logic [31:0] a_significand;
logic [31:0] b_significand;
logic a_sign;
logic b_sign;
logic [7:0] a_exp;
logic [7:0] b_exp;


//------------------------------------------------------------------------------
// Child module instances

ExtractModule extract_module
(
  .a(a),
  .b(b),
  .reset(reset),
  .a_significand(a_significand),
  .b_significand(b_significand),
  .a_sign(a_sign),
  .b_sign(b_sign),
  .a_exp(a_exp),
  .b_exp(b_exp)
);

ComputeModule compute_module
(
  .a_significand(a_significand),
  .b_significand(b_significand),
  .a_sign(a_sign),
  .b_sign(b_sign),
  .a_exp(a_exp),
  .b_exp(b_exp),
  .reset(reset),
  .result(result)
);

NormalizationModule normalization_module
(
  .result(result),
  .a_exp(a_exp),
  .reset(reset)
);

endmodule



//==============================================================================
//
// Module: ExtractModule (IEEE754Div.h:154:5)
//
module ExtractModule // "system.execute.fp_divider.extract_module"
(
    input logic [31:0] a,
    input logic [31:0] b,
    input logic reset,
    output logic [31:0] a_significand,
    output logic [31:0] b_significand,
    output logic a_sign,
    output logic b_sign,
    output logic [7:0] a_exp,
    output logic [7:0] b_exp
);

//------------------------------------------------------------------------------
// Method process: extract (IEEE754Div.h:15:5) 

always_comb 
begin : extract     // IEEE754Div.h:15:5
    if (reset)
    begin
        a_significand = 0;
        b_significand = 0;
        a_sign = 0;
        b_sign = 0;
        a_exp = 0;
        b_exp = 0;
    end else begin
        a_exp = (a & 'h7F800000) >>> 23;
        b_exp = (b & 'h7F800000) >>> 23;
        a_sign = (a & 32'h80000000) != 0;
        b_sign = (b & 32'h80000000) != 0;
        a_significand = (a & 'h7FFFFF) | 'h800000;
        b_significand = (b & 'h7FFFFF) | 'h800000;
    end
end

endmodule



//==============================================================================
//
// Module: ComputeModule (IEEE754Div.h:155:5)
//
module ComputeModule // "system.execute.fp_divider.compute_module"
(
    input logic [31:0] a_significand,
    input logic [31:0] b_significand,
    input logic a_sign,
    input logic b_sign,
    input logic [7:0] a_exp,
    input logic [7:0] b_exp,
    input logic reset,
    output logic [31:0] result
);

//------------------------------------------------------------------------------
// Method process: compute (IEEE754Div.h:50:5) 

always_comb 
begin : compute     // IEEE754Div.h:50:5
    logic [31:0] r;
    logic [7:0] result_exp;
    logic [4:0] i;
    logic odd;
    logic rnd;
    logic sticky;
    logic [31:0] x_val;
    logic [31:0] y_val;
    logic [7:0] shift;
    logic result_sign;
    r = 0;
    result_exp = 0;
    i = 0;
    odd = 0;
    rnd = 0;
    sticky = 0;
    x_val = 0;
    y_val = 0;
    shift = 0;
    result_sign = 0;
    if (reset)
    begin
        result = 0;
    end else begin
        r = 0;
        result_exp = 0;
        i = 0;
        x_val = 0;
        y_val = 0;
        shift = 0;
        result_sign = a_sign ^ b_sign;
        result_exp = a_exp - b_exp + 127;
        x_val = a_significand;
        y_val = b_significand;
        if (x_val < y_val)
        begin
            x_val = x_val <<< 1;
            result_exp = result_exp - 1;
        end
        r = 0;
        for (i = 0; i < 25; i++)
        begin
            r = r <<< 1;
            if (x_val >= y_val)
            begin
                x_val = x_val - y_val;
                r = r | 1;
            end
            x_val = x_val <<< 1;
        end
        sticky = x_val != 0;
        if ((result_exp >= 1) && (result_exp <= 254))
        begin
            rnd = |((r & 'h1000000) >>> 24);
            odd = (r & 'h2) != 0;
            r = (r >>> 1) + (rnd & (sticky | odd));
            r = (result_exp <<< 23) + (r - 'h800000);
        end else begin
            if (result_exp > 254)
            begin
                r = 'h7F800000;
            end else begin
                shift = 1 - result_exp;
                if (shift > 25)
                begin
                    shift = 25;
                end
                sticky = sticky | ((r & ~(~0 <<< shift)) != 0);
                r = r >>> shift;
                rnd = |((r & 'h1000000) >>> 24);
                odd = (r & 'h2) != 0;
                r = (r >>> 1) + (rnd & (sticky | odd));
            end
        end
        r = r | (result_sign ? 32'h80000000 : 0);
        result = r;
    end
end

endmodule



//==============================================================================
//
// Module: NormalizationModule (IEEE754Div.h:156:5)
//
module NormalizationModule // "system.execute.fp_divider.normalization_module"
(
    input logic [31:0] result,
    input logic [7:0] a_exp,
    input logic reset
);

//------------------------------------------------------------------------------
// Method process: normalize (IEEE754Div.h:128:5) 
// Empty process, no code generated 

endmodule



//==============================================================================
//
// Module: Memory (example.cpp:63:5)
//
module Memory // "system.memory"
(
    input logic reset,
    input logic stall,
    input logic valid_in,
    input logic [31:0] result_in,
    input logic [4:0] rd_in,
    input logic reg_write_in,
    input logic [31:0] instruction_in,
    output logic [31:0] result_out,
    output logic [4:0] rd_out,
    output logic reg_write_out,
    output logic valid_out,
    output logic [31:0] instruction_out
);

//------------------------------------------------------------------------------
// Method process: memory_process (mem_wb.h:16:5) 

always_comb 
begin : memory_process     // mem_wb.h:16:5
    result_out = 0;
    rd_out = 0;
    reg_write_out = 0;
    valid_out = 0;
    instruction_out = 0;
    if (!reset && !stall)
    begin
        result_out = result_in;
        rd_out = rd_in;
        reg_write_out = reg_write_in;
        valid_out = valid_in;
        instruction_out = instruction_in;
    end
end

endmodule



//==============================================================================
//
// Module: Writeback (example.cpp:64:5)
//
module Writeback // "system.writeback"
(
    input logic reset,
    input logic stall,
    input logic valid_in,
    input logic [31:0] result_in,
    input logic [4:0] rd_in,
    input logic reg_write_in,
    input logic [31:0] instruction_in,
    output logic [31:0] result_out,
    output logic [4:0] rd_out,
    output logic reg_write_en,
    output logic valid_out
);

//------------------------------------------------------------------------------
// Method process: writeback_process (mem_wb.h:67:5) 

always_comb 
begin : writeback_process     // mem_wb.h:67:5
    logic do_write;
    do_write = 0;
    result_out = 0;
    rd_out = 0;
    reg_write_en = 0;
    valid_out = 0;
    if (!reset && !stall)
    begin
        result_out = result_in;
        rd_out = rd_in;
        do_write = reg_write_in && valid_in && (instruction_in != 0);
        reg_write_en = do_write;
        valid_out = valid_in;
    end
end

endmodule



//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.13
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: ieee754_multiplier_5stage ()
//
module ieee754_multiplier_5stage // "ieee754_multiplier_5stage"
(
    input logic clk,
    input logic rst_n,
    input logic [31:0] A,
    input logic [31:0] B,
    output logic [31:0] O
);

// Variables generated for SystemC signals
logic [31:0] A_reg1;
logic [31:0] B_reg1;
logic sign_a_reg2;
logic sign_b_reg2;
logic [7:0] exp_a_reg2;
logic [7:0] exp_b_reg2;
logic [23:0] mant_a_reg2;
logic [23:0] mant_b_reg2;
logic special_case_reg2;
logic [31:0] special_result_reg2;
logic sign_a_reg3;
logic sign_b_reg3;
logic [7:0] exp_a_reg3;
logic [7:0] exp_b_reg3;
logic [31:0] mult_partial_reg3;
logic [23:0] mant_a_reg3;
logic [23:0] mant_b_reg3;
logic special_case_reg3;
logic [31:0] special_result_reg3;
logic result_sign_reg4;
logic [8:0] result_exp_reg4;
logic [47:0] mult_result_reg4;
logic special_case_reg4;
logic [31:0] special_result_reg4;

//------------------------------------------------------------------------------
// Clocked THREAD: input_stage (example.cpp:44:5) 

// Thread-local variables
logic [31:0] A_reg1_next;
logic [31:0] B_reg1_next;

// Next-state combinational logic
always_comb begin : input_stage_comb     // example.cpp:44:5
    input_stage_func;
end
function void input_stage_func;
    A_reg1_next = A_reg1;
    B_reg1_next = B_reg1;
    A_reg1_next = A;
    B_reg1_next = B;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync rst_n*/) 
begin : input_stage_ff
    if ( ~rst_n ) begin
        A_reg1 <= 0;
        B_reg1 <= 0;
    end
    else begin
        A_reg1 <= A_reg1_next;
        B_reg1 <= B_reg1_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: operand_prep_stage (example.cpp:57:5) 

// Thread-local variables
logic sign_a_reg2_next;
logic sign_b_reg2_next;
logic [7:0] exp_a_reg2_next;
logic [7:0] exp_b_reg2_next;
logic [23:0] mant_a_reg2_next;
logic [23:0] mant_b_reg2_next;
logic special_case_reg2_next;
logic [31:0] special_result_reg2_next;

// Next-state combinational logic
always_comb begin : operand_prep_stage_comb     // example.cpp:57:5
    operand_prep_stage_func;
end
function void operand_prep_stage_func;
    logic sign_a;
    logic sign_b;
    logic [7:0] exp_a;
    logic [7:0] exp_b;
    logic [23:0] mant_a;
    logic [23:0] mant_b;
    logic a_is_nan;
    logic b_is_nan;
    logic a_is_inf;
    logic b_is_inf;
    logic a_is_zero;
    logic b_is_zero;
    logic special_case;
    logic [31:0] special_result;
    exp_a_reg2_next = exp_a_reg2;
    exp_b_reg2_next = exp_b_reg2;
    mant_a_reg2_next = mant_a_reg2;
    mant_b_reg2_next = mant_b_reg2;
    sign_a_reg2_next = sign_a_reg2;
    sign_b_reg2_next = sign_b_reg2;
    special_case_reg2_next = special_case_reg2;
    special_result_reg2_next = special_result_reg2;
    sign_a = A_reg1[31];
    sign_b = B_reg1[31];
    exp_a = A_reg1[30 : 23];
    exp_b = B_reg1[30 : 23];
    mant_a = 0;
    mant_b = 0;
    if (exp_a == 0)
    begin
        mant_a = 24'({1'd0, A_reg1[22 : 0]});
    end else begin
        mant_a = 24'({1'd1, A_reg1[22 : 0]});
    end
    if (exp_b == 0)
    begin
        mant_b = 24'({1'd0, B_reg1[22 : 0]});
    end else begin
        mant_b = 24'({1'd1, B_reg1[22 : 0]});
    end
    a_is_nan = (exp_a == 'hFF) && (A_reg1[22 : 0] != 0);
    b_is_nan = (exp_b == 'hFF) && (B_reg1[22 : 0] != 0);
    a_is_inf = (exp_a == 'hFF) && (A_reg1[22 : 0] == 0);
    b_is_inf = (exp_b == 'hFF) && (B_reg1[22 : 0] == 0);
    a_is_zero = (exp_a == 0) && (A_reg1[22 : 0] == 0);
    b_is_zero = (exp_b == 0) && (B_reg1[22 : 0] == 0);
    special_case = 0;
    special_result = 0;
    if (a_is_nan || b_is_nan)
    begin
        special_case = 1;
        special_result = 32'({1'd0, 8'hFF, 23'h400000});
    end else begin
        if ((a_is_inf && b_is_zero) || (a_is_zero && b_is_inf))
        begin
            special_case = 1;
            special_result = 32'({1'd0, 8'hFF, 23'h400000});
        end else begin
            if (a_is_inf || b_is_inf)
            begin
                special_case = 1;
                special_result = 32'({1'(sign_a ^ sign_b), 8'hFF, 23'd0});
            end else begin
                if (a_is_zero || b_is_zero)
                begin
                    special_case = 1;
                    special_result = 32'({1'(sign_a ^ sign_b), 8'd0, 23'd0});
                end
            end
        end
    end
    sign_a_reg2_next = sign_a;
    sign_b_reg2_next = sign_b;
    exp_a_reg2_next = exp_a;
    exp_b_reg2_next = exp_b;
    mant_a_reg2_next = mant_a;
    mant_b_reg2_next = mant_b;
    special_case_reg2_next = special_case;
    special_result_reg2_next = special_result;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync rst_n*/) 
begin : operand_prep_stage_ff
    if ( ~rst_n ) begin
        sign_a_reg2 <= 0;
        sign_b_reg2 <= 0;
        exp_a_reg2 <= 0;
        exp_b_reg2 <= 0;
        mant_a_reg2 <= 0;
        mant_b_reg2 <= 0;
        special_case_reg2 <= 0;
        special_result_reg2 <= 0;
    end
    else begin
        sign_a_reg2 <= sign_a_reg2_next;
        sign_b_reg2 <= sign_b_reg2_next;
        exp_a_reg2 <= exp_a_reg2_next;
        exp_b_reg2 <= exp_b_reg2_next;
        mant_a_reg2 <= mant_a_reg2_next;
        mant_b_reg2 <= mant_b_reg2_next;
        special_case_reg2 <= special_case_reg2_next;
        special_result_reg2 <= special_result_reg2_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: mult_cycle1_stage (example.cpp:129:5) 

// Thread-local variables
logic sign_a_reg3_next;
logic sign_b_reg3_next;
logic [7:0] exp_a_reg3_next;
logic [7:0] exp_b_reg3_next;
logic [31:0] mult_partial_reg3_next;
logic [23:0] mant_a_reg3_next;
logic [23:0] mant_b_reg3_next;
logic special_case_reg3_next;
logic [31:0] special_result_reg3_next;

// Next-state combinational logic
always_comb begin : mult_cycle1_stage_comb     // example.cpp:129:5
    mult_cycle1_stage_func;
end
function void mult_cycle1_stage_func;
    logic [31:0] partial_mult;
    exp_a_reg3_next = exp_a_reg3;
    exp_b_reg3_next = exp_b_reg3;
    mant_a_reg3_next = mant_a_reg3;
    mant_b_reg3_next = mant_b_reg3;
    mult_partial_reg3_next = mult_partial_reg3;
    sign_a_reg3_next = sign_a_reg3;
    sign_b_reg3_next = sign_b_reg3;
    special_case_reg3_next = special_case_reg3;
    special_result_reg3_next = special_result_reg3;
    partial_mult = mant_a_reg2[15 : 0] * mant_b_reg2[15 : 0];
    sign_a_reg3_next = sign_a_reg2;
    sign_b_reg3_next = sign_b_reg2;
    exp_a_reg3_next = exp_a_reg2;
    exp_b_reg3_next = exp_b_reg2;
    mult_partial_reg3_next = partial_mult;
    mant_a_reg3_next = mant_a_reg2;
    mant_b_reg3_next = mant_b_reg2;
    special_case_reg3_next = special_case_reg2;
    special_result_reg3_next = special_result_reg2;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync rst_n*/) 
begin : mult_cycle1_stage_ff
    if ( ~rst_n ) begin
        sign_a_reg3 <= 0;
        sign_b_reg3 <= 0;
        exp_a_reg3 <= 0;
        exp_b_reg3 <= 0;
        mult_partial_reg3 <= 0;
        mant_a_reg3 <= 0;
        mant_b_reg3 <= 0;
        special_case_reg3 <= 0;
        special_result_reg3 <= 0;
    end
    else begin
        sign_a_reg3 <= sign_a_reg3_next;
        sign_b_reg3 <= sign_b_reg3_next;
        exp_a_reg3 <= exp_a_reg3_next;
        exp_b_reg3 <= exp_b_reg3_next;
        mult_partial_reg3 <= mult_partial_reg3_next;
        mant_a_reg3 <= mant_a_reg3_next;
        mant_b_reg3 <= mant_b_reg3_next;
        special_case_reg3 <= special_case_reg3_next;
        special_result_reg3 <= special_result_reg3_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: mult_cycle2_exp_stage (example.cpp:162:5) 

// Thread-local variables
logic result_sign_reg4_next;
logic [8:0] result_exp_reg4_next;
logic [47:0] mult_result_reg4_next;
logic special_case_reg4_next;
logic [31:0] special_result_reg4_next;

// Next-state combinational logic
always_comb begin : mult_cycle2_exp_stage_comb     // example.cpp:162:5
    mult_cycle2_exp_stage_func;
end
function void mult_cycle2_exp_stage_func;
    logic [47:0] full_mult_result;
    logic result_sign;
    logic [8:0] temp_exp;
    logic [8:0] result_exp;
    mult_result_reg4_next = mult_result_reg4;
    result_exp_reg4_next = result_exp_reg4;
    result_sign_reg4_next = result_sign_reg4;
    special_case_reg4_next = special_case_reg4;
    special_result_reg4_next = special_result_reg4;
    full_mult_result = mant_a_reg3 * mant_b_reg3;
    result_sign = (sign_a_reg3 ^ sign_b_reg3);
    temp_exp = exp_a_reg3 + exp_b_reg3;
    result_exp = 0;
    if (temp_exp >= 127)
    begin
        result_exp = temp_exp - 127;
    end else begin
        result_exp = 0;
    end
    result_sign_reg4_next = result_sign;
    result_exp_reg4_next = result_exp;
    mult_result_reg4_next = full_mult_result;
    special_case_reg4_next = special_case_reg3;
    special_result_reg4_next = special_result_reg3;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync rst_n*/) 
begin : mult_cycle2_exp_stage_ff
    if ( ~rst_n ) begin
        result_sign_reg4 <= 0;
        result_exp_reg4 <= 0;
        mult_result_reg4 <= 0;
        special_case_reg4 <= 0;
        special_result_reg4 <= 0;
    end
    else begin
        result_sign_reg4 <= result_sign_reg4_next;
        result_exp_reg4 <= result_exp_reg4_next;
        mult_result_reg4 <= mult_result_reg4_next;
        special_case_reg4 <= special_case_reg4_next;
        special_result_reg4 <= special_result_reg4_next;
    end
end

//------------------------------------------------------------------------------
// Clocked THREAD: normalize_round_stage (example.cpp:198:5) 

// Thread-local variables
logic [31:0] O_next;

// Next-state combinational logic
always_comb begin : normalize_round_stage_comb     // example.cpp:198:5
    normalize_round_stage_func;
end
function void normalize_round_stage_func;
    logic [31:0] final_result;
    logic [47:0] mult_result;
    logic [8:0] exp_result;
    logic sign_result;
    logic [22:0] final_mantissa;
    logic [7:0] final_exponent;
    logic [4:0] shift_count;
    logic [47:0] temp_mult;
    mult_result = 0;
    exp_result = 0;
    sign_result = 0;
    final_mantissa = 0;
    final_exponent = 0;
    shift_count = 0;
    temp_mult = 0;
    O_next = O;
    final_result = 0;
    if (special_case_reg4)
    begin
        final_result = special_result_reg4;
    end else begin
        mult_result = mult_result_reg4;
        exp_result = result_exp_reg4;
        sign_result = result_sign_reg4;
        if (mult_result == 0)
        begin
            final_result = 32'({sign_result, 8'd0, 23'd0});
        end else begin
            final_mantissa = 0;
            final_exponent = 0;
            if (mult_result[47])
            begin
                final_mantissa = mult_result[46 : 24];
                final_exponent = exp_result + 1;
            end else begin
                if (mult_result[46])
                begin
                    final_mantissa = mult_result[45 : 23];
                    final_exponent = exp_result;
                end else begin
                    shift_count = 0;
                    temp_mult = mult_result;
                    for (integer i = 45; i >= 23; i--)
                    begin
                        if (temp_mult[i])
                        begin
                            shift_count = 46 - i;
                            break;
                        end
                    end
                    temp_mult = temp_mult <<< shift_count;
                    final_mantissa = temp_mult[45 : 23];
                    if (exp_result > shift_count)
                    begin
                        final_exponent = exp_result - shift_count;
                    end else begin
                        final_exponent = 0;
                    end
                end
            end
            if (final_exponent >= 'hFF)
            begin
                final_result = 32'({sign_result, 8'hFF, 23'd0});
            end else begin
                if (final_exponent == 0)
                begin
                    final_result = 32'({sign_result, 8'd0, 23'd0});
                end else begin
                    final_result = 32'({sign_result, final_exponent, final_mantissa});
                end
            end
        end
    end
    O_next = final_result;
endfunction

// Synchronous register update
always_ff @(posedge clk /*sync rst_n*/) 
begin : normalize_round_stage_ff
    if ( ~rst_n ) begin
        O <= 0;
    end
    else begin
        O <= O_next;
    end
end

endmodule


